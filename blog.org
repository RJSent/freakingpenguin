#+AUTHOR: Richard Sent
#+HUGO_BASE_DIR: ./
#+PROPERTY: header-args:mermaid :eval yes
#+PROPERTY: header-args:gnuplot :eval yes
#+PROPERTY: header-args         :eval no-export :cache yes

* Homepage
:PROPERTIES:
:EXPORT_HUGO_SECTION: /
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_MENU: :menu "main"
:END:

This is the home of my blog!

* About
:PROPERTIES:
:EXPORT_FILE_NAME: about
:EXPORT_HUGO_SECTION: /
:END:

Hi there! I am an undergraduate student double majoring in Computer Engineering
and Physics at Cleveland State University.

Outside of taking super heavy course loads, I enjoy spending my free
time tinkering with technology. Often this means low-level
development, such as with ST microcontrollers.

I've done undergraduate research with the physics department at CSU,
even managing to combine my two degrees into a useful project! You can see
the source code for that project [[https:gitlab.com/rjsent/usra_video][here]].

I have experience with the following programming languages and tools:

- C

- Ruby

- Java

- VHDL

- Git

- Linux

  - [[https://www.gnu.org/gnu/incorrect-quotation.en.html][I'd just like to interject for a moment...]]

- Emacs / Emacs Lisp

- Nginx

  - This website is hosted on a virtual private server using Nginx!

- Hugo
  
Some general topics I find interesting are:

- Embedded development

- Hardware design and FPGAs

- Security

- Quantum Computing

- Systems Programming

- Open Source Software/Hardware

  - Here's hoping the PinePhone keeps succeeding!


Aside from that, I work to ensure that I'm not just learning the
syntactical grammar of a programming language, but also the underlying
concepts and good development practices. /Practical Object Oriented
Design/ by Sandi Metz provides an excellent overview from an
object-oriented standpoint, and I feel many of the core principles can
be applied to procedural languages like C. Maybe I'll write a post on this
once I finish /C Interfaces and Implementions/ by Hanson.

*** COMMENT Gitlab link issue

See https://github.com/kaushalmodi/ox-hugo/issues/236 for a more
detailed discussion on the issue and potential fix. I left a comment
since Hugo now uses Goldmark instead of Blackfriday by default, so the
Blackfriday bug should not be relevent.

** Personal

Outside of programming and physics, I enjoy the following:

- Camping and hiking

- Reading, both for education and recreation

- Traveling

- Cats

- Learning about new cultures

* TODO Projects

- List of projects, ala https://www.thomasvanderberg.nl/projects/

* Posts
:PROPERTIES:
:EXPORT_HUGO_SECTION: posts
:END:

** Blog Homepage
:PROPERTIES:
:EXPORT_HUGO_MENU: :menu "main"
:EXPORT_FILE_NAME: _index
:END:

Man, look at all my blog posts.

** COMMENT Testing ox-hugo
:PROPERTIES:
:EXPORT_FILE_NAME: testing-ox-hugo
:EXPORT_DATE: 2021-03-24
:END:

This is some text.

Here is an inline equation! \( F = ma \)

Here is an equation with the square brackets.

\[ \lambda = \frac{4309248302}{a_4 785494} \]

Here's a source block

#+begin_src C :includes stdio.h
  printf("Hello world!");
#+end_src

#+RESULTS:
: Hello world!

*** And here is a subheading!

With some text underneath!

*** Another one!

[[file:static/static/another_one.jpg]]

** Musings :@musings:

*** Are bus errors still commonplace? Plus a bonus discussion on =org-babel=. :C:low_level:org:babel:
:PROPERTIES:
:EXPORT_FILE_NAME: bus_errors_1
:EXPORT_DATE: 2021-03-24
:END:

#+begin_summary
Here, I explain what bus errors are and why they can occur. I explain
how we can use certain compiler flags to catch runtime errors that may
not actually occur. I explain how this improves program
portability. After all that, I get a minor headache trying to get
org-babel to display the results properly.
#+end_summary

#+hugo: more

**** What is a bus error?

I was reading through Peter Linden's /Expert C Programming/ when I noticed
an interesting example. On page 189, Peter talks about how one can
cause a bus error. I've never had a bus error occur before. Maybe
they're a solved problem?

Before we get too far ahead of ourselves, a bus error can occur when
we access a variable at an address that's not valid for that variable.
An address is not valid if the address is not evenly divisible by the
length of the variable. In other words...

#+begin_src C :exports code
  /* sizeof (int) == 4 */
  int p1 = *(int *) 5;
  /* Causes a bus error, 5 % 4 != 0 */

  int p2 = *(int *) 32;
  /* No bus error, 32 % 4 == 0 */
#+end_src

Realistically these programs would immediately seg fault as we
don't have access to arbitrary memory addresses. (Unless we were
working with embedded systems, perhaps...). To avoid this, we
can use a union.

**** Peter Linden's Code

Using the sample code in /Expert C Programming/, pg.
189, I am going to see if it causes a bus error.

The address of the union must be divisible by 4 (or ~sizeof int~),
as it can store an integer. As long as ~sizeof int > sizeof char~
(or ~sizeof int > 1~ as ~sizeof char == 1~), we can successfully
get our bus error.


#+begin_src C :includes stdio.h :exports both
  union {
    char a[10];
    int i;
  } u;
  int *p = (int *) &(u.a[1]);
  ,*p = 17;
  printf("*p %d\n", *p);
#+end_src

#+RESULTS:
: *p 17

Look at that! No problems. 

x86 is very forgiving when it comes to misalignment errors. For the
most part, they just don't happen. This is great for us, but what if
we ported this code over to a platform that is less friendly, like
ARM?

Ideally, we want to see if a bus error /can/ occur in our code, so
that way we can avoid them during development, as opposed to fixing it
later.

Looking through the =gcc= manual, I found a compile flag that will be
useful.

#+begin_quote
~fsanitize=undefined~

Enable UndefinedBehaviorSanitizer, a fast undefined behavior detector.
Various computations are instrumented to detect undefined behavior at
runtime.
#+end_quote

By adding the ~-fsanitize=undefined~ compile flag, our program will
print a runtime error whenever one occurs.

There are similar flags, ~-fsanitize=address~ and ~-fsanitize=thread~,
that can be useful for runtime error checking; look at the =gcc=
manual for more information. I can combine options with commas, i.e.
~-fsanitize=address,thread,undefined~.

**** ~-fsanitize=undefined~

There is one change that I need to make to the code. When a runtime
error occurs, the results are printed to =stderr=. When we're looking
at our code through a terminal, =stderr= and =stdout= might seem like
the exact same thing.

I am not running this code through a terminal. I'm using =org-babel=,
a very powerful tool for literate programming. If our
program runs successfully, =org-babel= will tell us the results.

Unfortunately, these results don't include =stderr=. In order to see
the runtime error occur, I need to close =stderr=, then change
=stderr='s file descriptor to point to =stdout=. This is what the
~dup2()~ function is doing.

#+begin_src C :includes stdio.h unistd.h :flags -Wall -fsanitize=undefined :results verbatim :exports both
  dup2(STDOUT_FILENO, STDERR_FILENO);

  union {
    char a[10];
    int i;
  } u;
  int *p = (int *) &(u.a[1]);
  ,*p = 17;
  printf("*p %d\n", *p);
  printf("p %lld\n", p);
#+end_src

#+RESULTS:
#+begin_example
/tmp/babel-YOFYnN/C-src-93AiCJ.c:17:6: runtime error: store to misaligned address 0x7ffec796bddd for type 'int', which requires 4 byte alignment
0x7ffec796bddd: note: pointer points here
 40 5a 14 84 55 00 00  e0 be 96 c7 fe 7f 00 00  00 f5 9a c3 4a 31 08 2e  00 00 00 00 00 00 00 00  25
             ^ 
/tmp/babel-YOFYnN/C-src-93AiCJ.c:18:3: runtime error: load of misaligned address 0x7ffec796bddd for type 'int', which requires 4 byte alignment
0x7ffec796bddd: note: pointer points here
 40 5a 14 84 11 00 00  00 be 96 c7 fe 7f 00 00  00 f5 9a c3 4a 31 08 2e  00 00 00 00 00 00 00 00  25
             ^ 
,*p 17
p 140732246965725
#+end_example

And it works! We can now see the runtime error! We're trying to access
an integer at address 140732246965725, which is not divisible by 4
(AKA ~sizeof int~). Thus, a bus error occurs.

**** Crash and burn programming

Running code and printing out runtime errors is great. However, there's a
saying in programming called "Fail early, fail often". What if we
don't just want an error message printed? What if, instead, we want
the program to immediately crash? After all, this is what would
actually happen if we were on a CPU architecture that couldn't handle
misaligned addresses.

I looked through the =gcc= manual and saw the ~-fno-sanitize-recover=all~
option. Supposedly, it does the following:

#+begin_quote
~-fsanitize-recover=all~ and ~-fno-sanitize-recover=all~ is also accepted,
the former enables recovery for all sanitizers that support it, the
latter disables recovery for all sanitizers that support it.
#+end_quote

Let's try it! I'm going to add ~-fno-sanitize-recover=all~ as a
compile flag. This should cause the program to immediately crash,
only printing the error message.

#+begin_src C :includes stdio.h unistd.h :flags -Wall -fsanitize=undefined -fno-sanitize-recover=all :results verbatim :exports both
  dup2(STDOUT_FILENO, STDERR_FILENO);

  union {
    char a[10];
    int i;
  } u;
  int *p = (int *) &(u.a[1]);
  ,*p = 17;
  printf("p %d\n", *p);
#+end_src

#+RESULTS:

Huh? Why wasn't the error message printed? Crashing the program is
what we wanted, but not without the error message! Without an error
message, all we're doing is making our program harder to debug.

Fortunately, this isn't our fault. The error message is actually being
printed, and it is being printed to =stdout=. If we were running our
program in a terminal, we'd see the error message we expect.

Unfortunately, this is a limitation of =org-babel=.
~-fno-sanitize-recover=all~ causes a nonzero exit code to be returned
on failure. =org-babel= does not like nonzero exit codes and fails to
evaluate ~stdout~ when this happens. It does evaluate ~stderr~ when
the exit code is nonzero, but only to a separate temporary buffer. At
least this works outside of =org-babel=.

There's a (brief) discussion of this issue on the mailing list [[https://lists.gnu.org/archive/html/emacs-orgmode/2016-05/msg00204.html][here]].
Given that this thread is 5 years old, I'm not holding my breath for a
fix.

There is an easy solution for ~sh~ scripts; just create a line at the
end with ~:~. Unfortunately since this is C, that's not really an
option.

**** Wrapping it up

The entire point of this endeavour is to try to make sure our code is
portable. When I write a program for one system, that program better
work on as many other systems as possible.

If any college students read this, professors don't like the "but it
worked on my machine!" excuse. (On the other hand, it takes one *mean*
professor to test with a different architecture in order to if you were
careful about memory alignment. We can't predict everything!)

~-fsanitize=undefined~ is a great flag to add when compiling; it
catches more than just memory alignment! If you add the flag and
forget about it, you will at least get a warning when undefined
behavior occurs! I'd much rather have a program that doesn't work but
I know why then a program that doesn't work and I don't know why.

** TODO Calculating a Fourier series in C, visualising one with GNUPlot :@fourier:

*** Fourier Part 1: What is a Fourier series? :C:math:gnuplot:GSL:
:PROPERTIES:
:EXPORT_FILE_NAME: fourier_series_1
:EXPORT_DATE: 2021-04-06
:END:

#+begin_summary
In this post, I begin work on calculating a Fourier series using C. I
explain why one would use a Fourier series instead of a simpler
alternative, such as Taylor series. Additionally, I cover how we
can use the GNU Scientific Library, or GSL, to perform definite
integration.
#+end_summary

#+hugo: more


**** COMMENT Use ~#+hugo: more~ as a content divider when using summaries!

https://ox-hugo.scripter.co/doc/hugo-summary-splitter/

Don't trust what the [[https://gohugo.io/content-management/summaries/][official docs]] say. That only applies if I was
using Hugo to read the org file directly. (Which I think they support?
If it's not, that's a bug.

**** An overview of Taylor series

A fourier expansion is a way for us to approximate a function. If
you've taken calculus before, you may have heard of a similar concept,
Taylor series. With Taylor series, we can approximate any function as
a sum of polynomials. For example, we can write \( \sin x \) as

\[ \sin x = x - \frac{x^3}{3!} + \frac{x^5}{5!} - \frac{x^7}{7!} +
\cdots \]

If we were to graph this, ([[https://www.desmos.com][try it!]]), we see that as more terms are
added, our approximation becomes more and more accurate. Here's a
small demonstration.

#+begin_src gnuplot :file static/static/gnuplot-taylor-example.png :exports results
  set title "Taylor Example"
  set xtics nomirror
  set yrange [-3:3]
  set xrange [-8:8]
  set grid
  set key left top
  set xzeroaxis lt 1 lc "black" lw 1
  set yzeroaxis lt 1 lc "black" lw 1
  set size ratio 0.7

  fac(x) = (int(x)==0) ? 1.0 : int(x) * fac(int(x)-1.0)
  taylor(x, i) = (-1)**i * (x**(2*i+1)) / fac(2*i+1)

  plot sin(x) lw 3 title "sin(x)", \
       sum [i=0:2] taylor(x, i) lw 2 title '3 terms', \
       sum [i=0:4] taylor(x, i) lw 2 title '5 terms'
#+end_src

#+RESULTS:
[[file:static/static/gnuplot-taylor-example.png]]

In the graph below, I tried demonstrating how the Taylor series can
"home in" on a function. Since we can't add part of a term in a Taylor
series, I tried to demonstrate this effect by multiplying the term by
a value. For example, when you see 1.1 terms, that means the first
term + 0.1 * the second term. For \( \sin x \), that's \( x - 0.1 *
\frac{x^3}{3!} \)

#+begin_src gnuplot :file static/static/gnuplot-taylor-animated-example.gif :exports results
  # delay <time> has time in units of 1/100 seconds
  # default delay between frames. Each plot generates a frame
  set terminal gif animate delay 3 loop 0
  set title "Taylor Series Animation"
  set xtics nomirror
  set yrange [-3:3]
  set xrange [-8:8]
  set grid
  set key left top
  set xzeroaxis lt 1 lc "black" lw 1
  set yzeroaxis lt 1 lc "black" lw 1
  set size ratio 0.7
  set samples 400

  fac(x) = (int(x)==0) ? 1.0 : int(x) * fac(int(x)-1.0)
  taylor(x, n) = (-1)**n * (x**(2*n+1)) / fac(2*n+1)

  # plot sin(x) lw 3 title "sin(x)"
  do for [i=0:9] {
      inner_loops = 60
      do for [j=0:inner_loops] {
	  plot (1.0*j/inner_loops) * taylor(x, i) + sum [n=0:i-1] taylor(x, n)\
	       lw 2 title sprintf("%.1f term%s", i+1.0*j/inner_loops, i+1.0*j/inner_loops > 0 ? "s" : " ")
      }
      # Only way I can think of "pausing" the animation.
      do for [j=0:inner_loops/3] {
	  plot (1.0) * taylor(x, i) + sum [n=0:i-1] taylor(x, n)\
	       lw 2 title sprintf("%.1f term%s", i+1.0, i+1.0 > 1 ? "s" : " ")
      }
  } 
#+end_src

#+RESULTS:
[[file:static/static/gnuplot-taylor-animated-example.gif]]

Now, Taylor series can be useful, but they have significant
limitations. First, we see that the Taylor series does a poor job
modeling periodic functions. Even though \( \sin x \) repeats, our
Taylor series does not. At large \(x\) values, this Taylor series is
completely wrong!

Second, a Taylor series relies on the function being continuous (no
holes or jumps). In addition to the function being continous, its
derivatives must be as well. Let's consider the following graph.

#+begin_src gnuplot :file static/static/gnuplot-discontinuous-derivative.png :exports results
  set title "Discontinuous Derivative"
  set xtics nomirror
  set yrange [-3:3]
  set xrange [-8:8]
  set grid
  set key left top
  set xzeroaxis lt 1 lc "black" lw 1
  set yzeroaxis lt 1 lc "black" lw 1
  set size ratio 0.7

  set samples 1000

  f(x)  = x > 0 ? x : -1*x
  fp(x) = x < -0.01 ? -1 : x < 0.01 ? NaN : 1

  plot f(x) lw 2, fp(x) lw 2 title "fprime(x)"
#+end_src

#+RESULTS:
[[file:static/static/gnuplot-discontinuous-derivative.png]]

Even though \( f(x) \) is continuous, its derivative \( f'(x) \) is
not. As such, a Taylor series cannot be used to approximate this
function. This issue would come up even if \( f''''''''''(x) \) was
discontinuous. (Keep in mind that discontinuous is not the same thing
as 0! We can model \( f(x) = x \) as a Taylor series, as its
higher order derivatives are continuous. They just also happen to be
0. Also, \( f(x) = x \) is its own Taylor series.)

So, to summarize, Taylor series have the following issues

1. They do not model periodic functions well

2. They require the function and all of its derivatives to be
   continuous


Fortunately, the Fourier series provides answers to both of these
problems! (At least for most functions. Some functions, like a
function that is discontinuous everywhere, exist solely for the
purpose of making us sad.)

***** COMMENT Org misidentifying list

When a number appears at the start of a line followed by a period and
1. space like this, org mode will treat that as a list. This isn't a
perfect solution, but we can insert a non breaking space with ~C-q 240
ret~ after the period. Credit to Andrew Swann [[https://emacs.stackexchange.com/a/10422][here]].

**** What we're all here for, Fourier series

I'll be sticking to the basics of Fourier series for now. Let's assume
we have a periodic function \( f(x) \) that has a period of \( T \). I
am going to introduce the symbol \( l \) where \( l = \frac{T}{2} \)
While this isn't the only option, we can write the Fourier series as

\[ f(x) = \sum_{n=0}^{\infty} a_n \cos(\frac{n \pi x}{l}) + b_n
\sin(\frac{n \pi x }{l} ) \]

In this case, we can find \( a_n \) and \( b_n \) with the formulas

\[ a_n = \frac{1}{l} \int_{0}^{2l} f(x) \cos(\frac{n \pi x }{l}) dx \]

\[ b_n = \frac{1}{l} \int_{0}^{2l} f(x) \sin(\frac{n \pi x }{l}) dx \]

I won't go into detail as to where these formulas come from. (That is
left as an exercise for the reader. Hah!) However, I will point out
that we can adjust the limits of integration to any values we want,
just as long as the difference between the upper and lower limits
equals our period.

There is one special case that we need to discuss. When \( n = 0 \),
we need a new formula for \( a_0 \). This formula will look like

\[ a_0 = \frac{1}{2l} \int_{0}^{2l} f(x) dx \]

Fortunately there is no special case for \( b_0 \). This occurs due to
the fact that \( a_0 \) is a constant term ( \( \cos 0 = 1 \) as
opposed to periodic.

That is all the theory that we need to calculate the Fourier series!
As long as we can find a library that can perform integration for us,
we should be able to calculate the Fourier series for any periodic
function.

**** Using GSL to calculate an integral

***** Explanation of ~gsl_integration_qng()~

Because of inscrutible magic mumbo jumbo, I decided to use C for
calculating the Fourier expansion. In order to do that, I needed to
pick out a library that could perform the integration for me. I
settled on =GSL= or the GNU Scientific Library. There are many, many,
MANY functions available in this library, but luckily I only need to
worry about integration.

Before going too far into Fourier stuff, I'm going to do a simple
sanity check so I can make sure I'm calculating integrals correctly. I
want to calculate the following integral.

\[ \int_{0}^{8} x dx \]

To do this using =GSL=, I can use the ~gsl_integration_qng()~
function. This function has the following signature.

#+begin_src C :eval no
  int gsl_integration_qng(const gsl_function * f,
			  double a, double b,
			  double epsabs, double epsrel,
			  double * result, double * abserr,
			  size_t * neval)
#+end_src

~f~ is a pointer to a structure that contains a function pointer. For
those who don't speak nerd, this is how ~gsl_integration_qng()~ knows
what function to integrate. It's our ~f(x)~. (Mostly. The reason for
making it a structure is because the structure also contains a ~void
*~ or void pointer. This void pointer can be used to pass parameters
to the function. This could be used to let us change the slope of the
function without having to modify the function itself.

~a~ and ~b~ are the lower and upper limits of integration. That's
fairly straightforward.

~epsabs~ and ~epsrel~ help ~gsl_integration_qng()~ decide when to stop
integrating. It's not possible to integrate the function to an exact
value with =GSL=. Instead, it tries to zero in on a specific value or
best guess as to what the answer is. ~epsabs~ is the absolute error
that we want. If ~epsabs~ = 0.1, we don't know what the answer is, but
we know we are no more than 0.1 away from it. ~epsrel~ is similar, but
percentage based instead of absolute. (e.g. ~epsrel~ = 0.01 means our
answer is within 1% of the actual value.)

~result~ and ~abserr~ are used by the function to store the result
and estimated absolute error, respectively. The number of iterations
it took to calculate the result is stored in ~neval~.

It is possible for the integration to fail. This might happen if we
set the error tolerances too tight. Since the function we're
integrating is so simple, I don't think that's a likely concern.

***** ~gsl_integration_qng()~ in use

To compile this program, you will need to tell the compiler what
external libraries to use. You can do with with the ~-lgsl~ compile
flag, e.g. ~gcc main.c -lgsl~. Because =GSL= depends on another
library, =CBLAS=, you will also need the ~-lcblas~ flag. If =CBLAS=
isn't available, you can use a version of =CBLAS= provided by =GSL=
with ~-lgslcblas~. (Don't forget to install =GSL=!) Since I'm using
some math function, I'm also going to include the math library with
~-lm~.

In the end, our command will look like ~gcc main.c -lgsl -lcblas -lm~,
which will compile =main.c= and create an output file =a.out=.
(Actually I'm using =org-babel= so I don't have to deal with this, but
I'm assuming most readers here are not.)

Alright! Time to integrate! I need to preface the =gsl_integration.h=
header with =gsl/= as the headers are installed in a =gsl=
subdirectory. (If you installed this through your systems package
manager, you can probably find this file in =/usr/include/gsl/=.)

#+begin_src C :libs -lgsl -lcblas -lm :eval no-export :exports both
  #include <stdio.h>
  #include <gsl/gsl_integration.h>
  #include <math.h>

  /* This is where we define the function */
  double f(double x, void *params) {
    return x;
  }

  int main() {
    double result, error;
    double low = 0, high = 8;
    gsl_function F = {.function = &f};
    double err_abs = 0, err_rel = 1;
    size_t num_evals;

    gsl_integration_qng(&F, low, high, err_abs, err_rel,
			&result, &error, &num_evals);
    printf("result error num_evals\n");
    printf("%f %f %zu\n", result, error, num_evals);
  }
#+end_src

#+RESULTS:
| result | error | num_evals |
|   32.0 |   0.0 |        21 |

There we go! =GSL= was able to successfully integrate \( \int_{0}^{8}
x dx \).

In the next part, we'll start using =GSL= to calculate the Fourier
series of a discontinuous, periodic function. We'll see if we can
naively get away with using the simple ~gsl_integration_qng()~
function, or if we need to find a more complicated, but more powerful, alternative.

*** TODO Fourier Part 2: Integrating a Discontinuous Function :C:math:gnuplot:GSL:
:PROPERTIES:
:EXPORT_FILE_NAME: fourier_series_2
:EXPORT_DATE: [2021-04-10 Sat]
:END:


#+begin_summary
In this post, I look at how we can integrate a discontinuous function.

#+end_summary

#+hugo: more

**** Checking if ~gsl_integration_qng()~ will work

At the end of [[*Fourier Part 1: What is a Fourier series?]], I suggested
that ~gsl_integraton_qng()~ would not be able to successfully
integrate the function we want to find the Fourier series of. Here is
the function I will find the Fourier series of.

#+begin_src gnuplot :file static/static/gnuplot-fourier-function-orig.png
  set title "Original Function"
  set xtics nomirror
  set grid
  set xrange [-8:8]
  set yrange [-2:6]
  set yzeroaxis lw 2
  set xzeroaxis lw 2
  set samples 1500
  set size ratio 0.7
  f(x) = (x - 4 * (floor(x/4) % 4) > 3.99) ? NaN : \
       x - 4 * (floor(x/4) % 4)
  plot f(x) lw 2 lc rgb "#009e73" notitle
#+end_src

#+RESULTS:
[[file:static/static/gnuplot-fourier-function-orig.png]]

Because this function is discontinuous, we have to approximate it with
a Fourier series instead of a Taylor series. If we recall the formulas
shown in the last part, we know that we will have to integrate \( f(x)
\) from \( 0 \) to \(2l\), among other things. Before calculating the
Fourier series, let's try using ~gsl_integration_qng()~ to perform
basic integration.

#+begin_src C :libs -lgsl -lcblas -lm :exports both
  #include <stdio.h>
  #include <math.h>
  #include <gsl/gsl_integration.h>

  /* f(x) = x for 0 <= x < 4, repeating */
  double f(double x, void *params) {
    const double period = 4;
    return fmod(x, period);
  }

  int main() {
    double result, error;
    double low = 0, high = 8;
    gsl_function F = {.function = &f};
    double err_abs = 0, err_rel = 1;
    size_t num_evals;

    gsl_integration_qng(&F, low, high,
			err_abs, err_rel,
			&result, &error, &num_evals);
    printf("result error num_evals\n");
    printf("%f %f %zu\n", result, error, num_evals);
  }
#+end_src

#+RESULTS:
|    result |    error | num_evals |
| 14.804436 | 8.015135 |        21 |

Well, something happened here, but it's not quite what we wanted. We
told =GSL= to take \( \int_0^8 f(x) dx \). Since we're dealing with a
discontinuous function, we can rewrite this as \( \int_0^4 x dx +
\int_4^8 x dx \) Now I'm no mathematician, but this answer should be
16, not 14.8. Additionally, our error is very large, and if I attempt
to lower ~err_rel~ to a smaller value, =GSL= yells at me saying that
it failed to reach the requested error.

This is not a problem on =GSL='s end. We aren't using the right
integration function for the job! According to the =GSL= manual,

#+begin_quote
The QNG algorithm is a non-adaptive procedure which uses fixed
Gauss-Kronrod-Patterson abscissae to sample the integrand at a maximum
of 87 points. It is provided for fast integration of smooth functions.
#+end_quote

While that's a lot of words, the important part is the last sentence.
~gsl_integration_qng()~ is for smooth functions. Our function is not
smooth, it has a discontinuity! We will need to find an alternative
function in =GSL= that can handle discontinuous graphs.

**** ~gsl_integration_qag()~ and discontinuities

Fortunately we do not have to look far. The very next function
mentioned in the [[https://www.gnu.org/software/gsl/doc/html/integration.html][manual]] is what we need. ~gsl_integration_qag()~ has
the following signature.

#+begin_src C
  int gsl_integration_qag(const gsl_function * f,
			  double a, double b,
			  double epsabs, double epsrel,
			  size_t limit, int key,
			  gsl_integration_workspace * workspace,
			  double * result, double * abserr)
#+end_src

~f~, ~a~, ~b~, ~epsabs~, ~epsrel~, ~result~, and ~abserr~ are all the
same as ~gsl_integration_qng()~. We can see that several new terms are
introduced however.

~workspace~ is a pointer to an area of memory used by
~gsl_integration_qag()~. We allocate space by using the
~gsl_integration_workspace_alloc()~ function, This function is passed
an integer to adjust how much memory we want to allocate. Whatever
integer we pass to ~gsl_integration_workspace_alloc()~,  we need to
ensure that ~limit~ is the same. This way, ~gsl_integration_qag()~
knows how much memory it has available.

~key~ is a integer between 0 through 6. =GSL= recommends using higher
values when integrating smooth functions, and lower values when
functions are discontinuous.

Let's see how well ~gsl_integration_qag()~ performs!

#+begin_src C :libs -lgsl -lcblas -lm :exports both
  #include <stdio.h>
  #include <gsl/gsl_integration.h>
  #include <math.h>

  double f(double x, void *params) {
    const double period = 4;
    double remainder = fmod(x, period);
    double f = remainder;
    return f;
  }

  int main() {
    size_t limit = 1024;
    gsl_integration_workspace *w
      = gsl_integration_workspace_alloc(limit);
    double result, error;
    double low = 0, high = 8;
    gsl_function F = {.function = &f};
    double err_abs = 0, err_rel = 1e-7;

    gsl_integration_qag(&F, low, high,
			err_abs, err_rel,
			limit, 1, w,
			&result, &error);
    /* get into the habit of freeing memory when done! */
    gsl_integration_workspace_free(w);
    printf("result error\n");
    printf("%f %f\n", result, error);
  }
#+end_src

#+RESULTS:
| result | error |
|   16.0 |   0.0 |

Look at that! We are getting the exact value we expected, even though
we're integrating with a discontinuity. We are now at the point where
we can calculate the Fourier series for our function.


**** Generating our Fourier series

Let's recall that we can find our \(a_n\) and \(b_n\) coefficients
with the following formulas.

\[ a_n = \frac{1}{l} \int_{0}^{2l} f(x) \cos(\frac{n \pi x }{l}) dx \]

\[ b_n = \frac{1}{l} \int_{0}^{2l} f(x) \sin(\frac{n \pi x }{l}) dx \]

=GSL= expects us to only pass one function to it as an argument. That
means that, unlike before, we can't just pass a pointer to our function
~f(x)~, as =GSL= won't be multiplying it by the cosine and sine terms.

There are a couple of solutions to this that I can think of. The first
is to make use of the ~void *~ argument that =GSL= includes in the
~gsl_function~ structure. Using this, we could pass extra information
to ~f(x)~, adapting it to our specific n value.

Alternatively, we could write a parent function, like ~aorb_subn()~. This
function would then be stored in the ~gsl_function~ structure. The
advantage of this approach is that the function we want the Fourier
series of, ~f(x)~, is distinct in our code. This should make it a bit
easier to change ~f(x)~ to any function that we want. This is the
approach that I will take.

To make this code hopefully a bit more modular, I moved the
integration out of main, and instead into a function called
~get_aorb_subn()~. This function calculates the nth Fourier
coefficient for a function ~f(x)~, using the variable ~get_a~ to
determine if it should calculate \( a_n \) or \( b_n \). It may be
better to wrap this in a ~fourier~ structure that contains the two
terms, but I elected not to do that to hopefully maintain some vague
semblance of readability.

This is what the code to calculate the Fourier series looks like.

#+begin_src C :libs -lgsl -lgslcblas -lm :colnames '("n" "a_subn" "b_subn") :exports both
  #include <stdbool.h>
  #include <stdio.h>
  #include <math.h>
  #include <gsl/gsl_integration.h>

  #define PI 3.14159
  const double period = 4;
  const double l = period / 2;

  struct aorb_params {
    double (*f)(double x, void *params);
    int n;
    bool calc_a;
  };

  double f(double x, void *params) {
    return fmod(x, period);
  }

  /* g(x, n, a_or_b) */
  double aorb_subn(double x, struct aorb_params *params) {
    int n = params->n;
    double trig = params->calc_a ? cos(PI*n*x/l) : sin(PI*n*x/l);
    return params->f(x, NULL) * trig;
  }

  double get_aorb_subn(double (*f)(double x, void *params), int n, 
		       double low, double high, bool get_a) {
    double normalization = 1/l;
    if (get_a && n == 0) normalization /= 2;

    size_t limit = 1024;
    gsl_integration_workspace *w
      = gsl_integration_workspace_alloc(limit);
    double result, error;
    gsl_function F = { .function = &aorb_subn,
      .params = &(struct aorb_params){ .f = f, .n = n,
			.calc_a = get_a } };
    double err_abs = 0, err_rel = 1e-7;

    gsl_integration_qag(&F, low, high,
			err_abs, err_rel,
			limit, 1, w,
			&result, &error);
    gsl_integration_workspace_free(w);

    return normalization * result;
  }

  int main() {
    const int upto = 10;
    double a_subn[upto], b_subn[upto];
    double low = 0, high = period;

    for (int i = 0; i < upto; i++) {
      a_subn[i] = get_aorb_subn(f, i, low, high, true);
      b_subn[i] = get_aorb_subn(f, i, low, high, false);
      printf("%d %f %f\n", i, a_subn[i], b_subn[i]);
    }
  }
#+end_src

#+NAME: tbl-fourier-asubn-bsubn
#+RESULTS: babel-fourier-asubn-bsubn
| n | a_subn |    b_subn |
|---+--------+-----------|
| 0 |    2.0 |       0.0 |
| 1 | -7e-06 | -1.273242 |
| 2 | -7e-06 | -0.636621 |
| 3 | -7e-06 | -0.424414 |
| 4 | -7e-06 |  -0.31831 |
| 5 | -7e-06 | -0.254648 |
| 6 | -7e-06 | -0.212207 |
| 7 | -7e-06 | -0.181892 |
| 8 | -7e-06 | -0.159155 |
| 9 | -7e-06 | -0.141471 |

Like I mentioned before, ~aorb_subn~ is a "parent function", that
combines ~f(x)~ and a sine/cosine term. In math terms, it is like going
from \(f(x) \cos(\frac{n \pi x }{l}) \) and \(f(x) \sin(\frac{n \pi x
}{l}) \) to \( g(x, n, a \_ or \_ b) \).

Interestingly, if we use the \( \pi \) constant ~M_PI~, the integration
fails due to roundoff error. Fortunately we can get "close enough"
values by just using a few less digits.

Once we graph the Fourier series generated by these coefficients, this
is what we get.

#+begin_src gnuplot :var data=tbl-fourier-asubn-bsubn :file static/static/gnuplot-asubn-bsubn.png :exports results
  set title "Fourier Series"
  set xtics nomirror
  set yrange [-2:6]
  set xrange [-8:8]
  set grid
  set yzeroaxis lw 2
  set xzeroaxis lw 2
  set size ratio 0.7
  set samples 200
  getValue(row,col,filename) = system('awk ''{if (NR == '.row.') print $'.col.'}'' '.filename.'')
  fourier(x, n) = getValue(n+1, 2, data) * cos(pi*n*x/2) + getValue(n+1, 3, data) * sin(pi*n*x/2)
  # todo automatically iterate # rows in table
  plot sum [n=0:9] fourier(x, n) notitle
#+end_src

#+RESULTS:
[[file:static/static/gnuplot-asubn-bsubn.png]]

And there we are! A fourier expansion generated for a discontinuous
periodic function. The more terms we add, the more accurate the approximation.

***** COMMENT GNUPlot fails to generate above graph on export

I suspect the issue here is that the data table is not available on
export. To fix this for right now, I am now executing the C block on
export. This isn't a sustainable solution since it requires the
libraries to be present on any server.

I found a better solution. Manually give the table a name.

** TODO stm8-card						  :@stm8_card:

*** COMMENT Outline

- I would like to cover the following

  - Dependencies (mermaid graphs), both what I current have and what I
    want to turn it into

  - My implementation of 256 byte framebuffer for 512 byte display

  - Issues that came up during development

    - Not remaking compilation units properly when changing function
      prototypes (commit 360dc35)

      - Compiled main with int arguments to ~i2c_send_bytes()~,
        changed in ~char~ in i2c.h, but main wasn't recompiled. Fixed
        with ~$ make clean~.

      - Also present in 170cf61

      - Would like to adjust makefile to
        automatically recompile based on dependencies / includes

    - Undefined behavior with overflow in ~space_invader.c~
      ~player_laser_tick()~. If statement right before return (present
      in commit 881c70c) overflows, relying on undefined behavior that
      overflow of signed char goes to < 0

    - Baud rate of UART, 80x less than what was expected (double check numbers)

      - HSI prescaler fixed the problem, supposedly divided clock to uart
        by factor of 8 (16 mhz -> 2 mhz), further divided by BRR1 and
        BRR2 to 9600 baud rate

	- But my baud rate was off by a factor of 80, not 8. There's a
          factor of 10 I can't account for

    - Limitations of sdcc, no passing structures directly, only pointers

      - No compound literals making initialization of nested
        structures ugly

    - Packing of structures, see comment in ~space_invader.c~ line
      18-30 in commit 881c70c

    - Padding in memory map, see commit 63ad629

      - No functional purpose I could find, takes almost 1% of my heap
        / static memory!

*** TODO stm8-card: Dependencies
:PROPERTIES:
:EXPORT_FILE_NAME: stm8-card-deps
:END:

Ideally, the dependencies would look like this.

~baseline~ is meant to represent a collection of useful macros and
maybe functions. (e.g. ~SIZEOFARRAY()~, ~CONTAINER_OF()~, etc)

~hal~ and ~stm8_board_lib~ are libraries that would be formed from
combining several pieces. The ~hal~ is a hardware abstraction library,
providing a consistent API that any code I write can use. I can "slot
in" any board lib, like the ~stm8_board_lib~, to port the code to a
different microcontroller. This will require a *lot* of restructuring
of the component pieces (~uart~. ~i2c~, etc).

#+begin_src mermaid :file static/static/mermaid-stm8-card-dep-graph.png :theme neutral :background_color transparent :exports results
graph TD;

main --- space_invader & ssd1306 & baseline & hal

space_invader & ssd1306 --- image

hal --- stm8_board_lib
stm8_board_lib --- gpio & i2c & registers & ...
#+end_src

#+RESULTS:
[[file:static/static/mermaid-stm8-card-dep-graph.png]]

Currently, they look something like this. (Double check and remake if
needed, going off of memory) [2021-03-26 Fri]

#+begin_src mermaid :file static/static/mermaid-stm8-card-dep-graph-current.png :theme neutral :background_color transparent :exports results
graph TD;

main --- space_invader & ssd1306 & baseline & i2c & uart & image

ssd1306 --- i2c & uart & baseline & image
space_invader --- image & baseline
image --- baseline
baseline --- registers
blink_code --- baseline & registers & gpio

i2c --- registers & baseline
uart --- registers

#+end_src

#+RESULTS:
[[file:static/static/mermaid-stm8-card-dep-graph-current.png]]

*** TODO stm8-card: Part 1
:PROPERTIES:
:EXPORT_FILE_NAME: stm8-card-1
:END:

* TODOs

** DONE autogenerate =ob-mermaid= graphs instead of committing pictures
CLOSED: [2021-03-27 Sat 14:50]

- Add to the publish script so that =static/static/*.png= is
  autogenerated for =ob-mermaid= graphs. I don't want redundant
  commits or to risk forgetting to export a graph.

- The problem right now is that when the ~#+RESULTS:~ are present, the
  exporter will not regenerate the files if they are missing. This
  behavior is inconsistent with, at least, org latex export, which
  does evaluate the code blocks.

  - Write a minimal example and submit a bug report [[https://github.com/kaushalmodi/ox-hugo][here]].

- Nevermind! No bug report was necessary (fortunately figured it out
  before submitting one). I was just an idiot and forgot to add
  mermaid to ~org-babel-load-languages~ in the script, meaning mermaid
  source blocks were not evaluated.

  - When I published to LaTeX, my Emacs config handles adding to
    ~org-babel-load-languages~ automatically, so I didn't notice.

** DONE Create consistent naming scheme for =ob-mermaid= graphs
CLOSED: [2021-03-27 Sat 14:50]

- Then I can add them to a =.gitignore= in =static/static=

*** TODO Possible to concatenate to ~:file~ header arg?

- e.g. ~:file $MERMAID_PREFIXname~
