#+AUTHOR: Richard Sent
#+HUGO_BASE_DIR: ./
#+PROPERTY: header-args:mermaid :eval yes
#+PROPERTY: header-args:gnuplot :eval yes
#+PROPERTY: header-args         :eval no-export

* Homepage
:PROPERTIES:
:EXPORT_HUGO_SECTION: /
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_MENU: :menu "main"
:END:

This is the home of my blog!

* About
:PROPERTIES:
:EXPORT_FILE_NAME: about
:EXPORT_HUGO_SECTION: /
:END:

Hi there! I am an undergraduate student double majoring in Computer Engineering
and Physics at Cleveland State University.

Outside of taking super heavy course loads, I enjoy spending my free
time tinkering with technology. Often this means low-level
development, such as with ST microcontrollers.

I've done undergraduate research with the physics department at CSU,
even managing to combine my two degrees into a useful project! You can see
the source code for that project [[https:gitlab.com/rjsent/usra_video][here]].

I have experience with the following programming languages and tools:

- C

- Ruby

- Java

- VHDL

- Git

- Linux

  - [[https://www.gnu.org/gnu/incorrect-quotation.en.html][I'd just like to interject for a moment...]]

- Emacs / Emacs Lisp

- Nginx

  - This website is hosted on a virtual private server using Nginx!

- Hugo
  
Some general topics I find interesting are:

- Embedded development

- Hardware design and FPGAs

- Security

- Quantum Computing

- Systems Programming

- Open Source Software/Hardware

  - Here's hoping the PinePhone keeps succeeding!


Aside from that, I work to ensure that I'm not just learning the
syntactical grammar of a programming language, but also the underlying
concepts and good development practices. /Practical Object Oriented
Design/ by Sandi Metz provides an excellent overview from an
object-oriented standpoint, and I feel many of the core principles can
be applied to procedural languages like C. Maybe I'll write a post on this
once I finish /C Interfaces and Implementions/ by Hanson.

*** COMMENT Gitlab link issue

See https://github.com/kaushalmodi/ox-hugo/issues/236 for a more
detailed discussion on the issue and potential fix. I left a comment
since Hugo now uses Goldmark instead of Blackfriday by default, so the
Blackfriday bug should not be relevent.

** Personal

Outside of programming and physics, I enjoy the following:

- Camping and hiking

- Reading, both for education and recreation

- Traveling

- Cats

- Learning about new cultures

* TODO Projects

- List of projects, ala https://www.thomasvanderberg.nl/projects/

* Posts
:PROPERTIES:
:EXPORT_HUGO_SECTION: posts
:END:

** Blog Homepage
:PROPERTIES:
:EXPORT_HUGO_MENU: :menu "main"
:EXPORT_FILE_NAME: _index
:END:

Man, look at all my blog posts.

** COMMENT Testing ox-hugo
:PROPERTIES:
:EXPORT_FILE_NAME: testing-ox-hugo
:EXPORT_DATE: 2021-03-24
:END:

This is some text.

Here is an inline equation! \( F = ma \)

Here is an equation with the square brackets.

\[ \lambda = \frac{4309248302}{a_4 785494} \]

Here's a source block

#+begin_src C :includes stdio.h
  printf("Hello world!");
#+end_src

#+RESULTS:
: Hello world!

*** And here is a subheading!

With some text underneath!

*** Another one!

[[file:static/static/another_one.jpg]]

** Musings :@musings:

*** Are bus errors still commonplace? Plus a bonus discussion on =org-babel=. :C:low_level:babel:
:PROPERTIES:
:EXPORT_FILE_NAME: bus_errors_1
:EXPORT_DATE: 2021-03-24
:END:

#+begin_summary
Here, I explain what bus errors are and why they can occur. I explain
how we can use certain compiler flags to catch runtime errors that may
not actually occur. I explain how this improves program
portability. After all that, I get a minor headache trying to get
org-babel to display the results properly.
#+end_summary

#+hugo: more

**** What is a bus error?

I was reading through Peter Linden's /Expert C Programming/ when I noticed
an interesting example. On page 189, Peter talks about how one can
cause a bus error. I've never had a bus error occur before. Maybe
they're a solved problem?

Before we get too far ahead of ourselves, a bus error can occur when
we access a variable at an address that's not valid for that variable.
An address is not valid if the address is not evenly divisible by the
length of the variable. In other words...

#+begin_src C :exports code
  /* sizeof (int) == 4 */
  int p1 = *(int *) 5;
  /* Causes a bus error, 5 % 4 != 0 */

  int p2 = *(int *) 32;
  /* No bus error, 32 % 4 == 0 */
#+end_src

Realistically these programs would immediately seg fault as we
don't have access to arbitrary memory addresses. (Unless we were
working with embedded systems, perhaps...). To avoid this, we
can use a union.

**** Peter Linden's Code

Using the sample code in /Expert C Programming/, pg.
189, I am going to see if it causes a bus error.

The address of the union must be divisible by 4 (or ~sizeof int~),
as it can store an integer. As long as ~sizeof int > sizeof char~
(or ~sizeof int > 1~ as ~sizeof char == 1~), we can successfully
get our bus error.


#+begin_src C :includes stdio.h :exports both
  union {
    char a[10];
    int i;
  } u;
  int *p = (int *) &(u.a[1]);
  ,*p = 17;
  printf("*p %d\n", *p);
#+end_src

#+RESULTS:
: *p 17

Look at that! No problems. 

x86 is very forgiving when it comes to misalignment errors. For the
most part, they just don't happen. This is great for us, but what if
we ported this code over to a platform that is less friendly, like
ARM?

Ideally, we want to see if a bus error /can/ occur in our code, so
that way we can avoid them during development, as opposed to fixing it
later.

Looking through the =gcc= manual, I found a compile flag that will be
useful.

#+begin_quote
~fsanitize=undefined~

Enable UndefinedBehaviorSanitizer, a fast undefined behavior detector.
Various computations are instrumented to detect undefined behavior at
runtime.
#+end_quote

By adding the ~-fsanitize=undefined~ compile flag, our program will
print a runtime error whenever one occurs.

There are similar flags, ~-fsanitize=address~ and ~-fsanitize=thread~,
that can be useful for runtime error checking; look at the =gcc=
manual for more information. I can combine options with commas, i.e.
~-fsanitize=address,thread,undefined~.

**** ~-fsanitize=undefined~

There is one change that I need to make to the code. When a runtime
error occurs, the results are printed to =stderr=. When we're looking
at our code through a terminal, =stderr= and =stdout= might seem like
the exact same thing.

I am not running this code through a terminal. I'm using =org-babel=,
a very powerful tool for literate programming. If our
program runs successfully, =org-babel= will tell us the results.

Unfortunately, these results don't include =stderr=. In order to see
the runtime error occur, I need to close =stderr=, then change
=stderr='s file descriptor to point to =stdout=. This is what the
~dup2()~ function is doing.

#+begin_src C :includes stdio.h unistd.h :flags -Wall -fsanitize=undefined :results verbatim :exports both
  dup2(STDOUT_FILENO, STDERR_FILENO);

  union {
    char a[10];
    int i;
  } u;
  int *p = (int *) &(u.a[1]);
  ,*p = 17;
  printf("*p %d\n", *p);
  printf("p %lld\n", p);
#+end_src

#+RESULTS:
#+begin_example
/tmp/babel-YOFYnN/C-src-93AiCJ.c:17:6: runtime error: store to misaligned address 0x7ffec796bddd for type 'int', which requires 4 byte alignment
0x7ffec796bddd: note: pointer points here
 40 5a 14 84 55 00 00  e0 be 96 c7 fe 7f 00 00  00 f5 9a c3 4a 31 08 2e  00 00 00 00 00 00 00 00  25
             ^ 
/tmp/babel-YOFYnN/C-src-93AiCJ.c:18:3: runtime error: load of misaligned address 0x7ffec796bddd for type 'int', which requires 4 byte alignment
0x7ffec796bddd: note: pointer points here
 40 5a 14 84 11 00 00  00 be 96 c7 fe 7f 00 00  00 f5 9a c3 4a 31 08 2e  00 00 00 00 00 00 00 00  25
             ^ 
,*p 17
p 140732246965725
#+end_example

And it works! We can now see the runtime error! We're trying to access
an integer at address 140732246965725, which is not divisible by 4
(AKA ~sizeof int~). Thus, a bus error occurs.

**** Crash and burn programming

Running code and printing out runtime errors is great. However, there's a
saying in programming called "Fail early, fail often". What if we
don't just want an error message printed? What if, instead, we want
the program to immediately crash? After all, this is what would
actually happen if we were on a CPU architecture that couldn't handle
misaligned addresses.

I looked through the =gcc= manual and saw the ~-fno-sanitize-recover=all~
option. Supposedly, it does the following:

#+begin_quote
~-fsanitize-recover=all~ and ~-fno-sanitize-recover=all~ is also accepted,
the former enables recovery for all sanitizers that support it, the
latter disables recovery for all sanitizers that support it.
#+end_quote

Let's try it! I'm going to add ~-fno-sanitize-recover=all~ as a
compile flag. This should cause the program to immediately crash,
only printing the error message.

#+begin_src C :includes stdio.h unistd.h :flags -Wall -fsanitize=undefined -fno-sanitize-recover=all :results verbatim :exports both
  dup2(STDOUT_FILENO, STDERR_FILENO);

  union {
    char a[10];
    int i;
  } u;
  int *p = (int *) &(u.a[1]);
  ,*p = 17;
  printf("p %d\n", *p);
#+end_src

#+RESULTS:

Huh? Why wasn't the error message printed? Crashing the program is
what we wanted, but not without the error message! Without an error
message, all we're doing is making our program harder to debug.

Fortunately, this isn't our fault. The error message is actually being
printed, and it is being printed to =stdout=. If we were running our
program in a terminal, we'd see the error message we expect.

Unfortunately, this is a limitation of =org-babel=.
~-fno-sanitize-recover=all~ causes a nonzero exit code to be returned
on failure. =org-babel= does not like nonzero exit codes and fails to
evaluate ~stdout~ when this happens. It does evaluate ~stderr~ when
the exit code is nonzero, but only to a separate temporary buffer. At
least this works outside of =org-babel=.

There's a (brief) discussion of this issue on the mailing list [[https://lists.gnu.org/archive/html/emacs-orgmode/2016-05/msg00204.html][here]].
Given that this thread is 5 years old, I'm not holding my breath for a
fix.

There is an easy solution for ~sh~ scripts; just create a line at the
end with ~:~. Unfortunately since this is C, that's not really an
option.

**** Wrapping it up

The entire point of this endeavour is to try to make sure our code is
portable. When I write a program for one system, that program better
work on as many other systems as possible.

If any college students read this, professors don't like the "but it
worked on my machine!" excuse. (On the other hand, it takes one *mean*
professor to test with a different architecture in order to if you were
careful about memory alignment. We can't predict everything!)

~-fsanitize=undefined~ is a great flag to add when compiling; it
catches more than just memory alignment! If you add the flag and
forget about it, you will at least get a warning when undefined
behavior occurs! I'd much rather have a program that doesn't work but
I know why then a program that doesn't work and I don't know why.

*** DONE Circular pointers in C						  :C:
CLOSED: [2021-04-15 Thu 12:35]
:PROPERTIES:
:EXPORT_DATE: [2021-04-15 Thu]
:EXPORT_FILE_NAME: circular_pointers
:END:

#+begin_summary
In this post, I mess around with pointers in ways that are definitely
not intended. I discuss several pitfalls when creating a pointer that
points to itself. I create two possible implementations of circular
pointers, and also find a limitation in C at the very end.
#+end_summary

#+hugo: more

**** What is a circular pointer?

Full disclosure, I almost cannot think of any practical value to this
post. It's provided also entirely as a "Huh, that's a weird thing you
can do in C", rather than an actually useful technique. The only
purpose I can see is to use them for a circularly linked list with one
element. There may be another term that's in use, but I do not know
what it is.

A circular pointer is a pointer that, well, points to itself! No
matter how many times we dereference that pointer, we should still be
at the same spot. For example,

#+begin_src mermaid :file static/static/mermaid-circular-pointer-example.png :theme neutral :background-color transparent :exports results
graph BT
p -->|*p| p
#+end_src

#+RESULTS:
[[file:static/static/mermaid-circular-pointer-example.png]]

Another way to think about it is ~****p == p~. Let's try to think of
some ways to implement this!

**** Failed Attempt

The first thought that might come to our mind might be something like
what's below. Because (spoilers) this code seg faults, I wrote a
signal handler so we still see some kind of results.

Calling most library functions in signal handlers is a bad idea, so
I'm using the ~write()~ system call. Headers are excluded for
compactness. I'm using ~fflush()~ as ~printf()~ buffers its output.
Otherwise, the first ~printf()~ will not appear. Lastly, even though
an error occurs, I'm exiting with a zero exit code because of
=org-babel= limitations. You can find out more about this in [[*Crash
and burn programming][this post]].

#+begin_comment
 I'll be using the ~dup2()~ call so we can see what
~stderr~ is printing, just like what we do in [[*Are bus errors still
commonplace? Plus a bonus discussion on =org-babel=.][Are bus errors
still commonplace?]]

Insert internal links with [[* followed by C-M-i or <Esc> <Tab>.
(M-TAB is intercepted by most DEs. )You can optionally type a few
letters, but make sure there's no spaces between * and point, even if
it's part of the heading.

Not sure why =org-babel= is displayed in the link, it shouldn't be.

Maybe I should use ~counsel-org-link~ instead.

Actually no, there's a bug in =ox-hugo= where links do not work when
an id property is used.
#+end_comment

#+begin_src C :includes <stdio.h> <unistd.h> <signal.h> :results verbatim :exports both
  void segfault(int sig_num) {
    fflush(stdout);
    write(STDOUT_FILENO, "Segfault!\n", 9);
    _exit(0);
  }

  int main(void) {
    signal(SIGSEGV, segfault);
    int *p;
    printf("p 0x%x\n", p);
    ,*p = p; /* segfault occurs here */
    printf("****p %x", ****(int ****)p);
  }
#+end_src

#+RESULTS:
: p 0x0
: Segfault!

If we walk through the code, we can figure out the problem. We
allocate space for an integer pointer p, which contains 0. We then
attempt to store the value in p, 0, in the value pointed to by p, 0.
In other words, we're attempting to dereference a ~NULL~ pointer,
causing a seg fault.

**** Some background

Okay, so all we need to do is ~malloc()~ space for the pointer p to
point to. Easy, right? Before we get to that though, there's a few
things we have to keep in mind.

***** Malloc with multiple levels of pointers

First, we need to be careful
allocating space for variables when using multiple levels of pointers.
For example,

#+begin_src C :includes <stdio.h> <malloc.h>
  int **p = malloc(sizeof (int));
  ,**p = 1;
#+end_src

will seg fault! p is a pointer to a pointer containing an int. When we
malloc memory, malloc will return a pointer to a block of memory large
enough to contain an int. If we type ~**p~, we're saying "Go to the
malloced block, then go to where the malloced block is pointing at
and set that block to 1". Because ~malloc()~'d memory can be anything,
we are accessing memory at random! This is an easy recipe for a seg
fault. One way to fix this is to use multiple variables, for
instance...

#+begin_src C :includes <stdio.h> <malloc.h>
  int *p1  = malloc(sizeof (int));
  int **p2 = &p1;
  ,**p2    = 7;
  printf("***p2 %d", **p2);
#+end_src

#+RESULTS:
: ***p2 7

***** Compile time errors dereferencing pointers

Next up, if we have ~int *p~, then ~p~ is an ~int *~. If we try to do ~**p~, our
compiler will complain about an invalid type argument and fail to compile. You can't
dereference an ~int *~ two times!

The compiler helpfully assumes that you would never dereference a
pointer more than the number of pointers you have. In other words,

#+begin_src C :includes <stdio.h> <malloc.h> :eval no :exports code
  int *p = malloc(sizeof (int));
  printf("*p1 %d\n", *p);
#+end_src

will compile, but

#+begin_src C :includes <stdio.h> <malloc.h> :eval no :exports code
  int *p  = malloc(sizeof (int));
  printf("**p1 %d\n", **p);
#+end_src

will not compile. The compiler sees that *p1 is an int pointer, so it
knows ~**p~ is always invalid. If we pretend seg faults don't exist
for a second, we can fix this issue using casts! A cast tells the
compiler "Hey, I know that ~p~ is an integer pointer, but I need you
to treat this as another type for right now".

#+begin_src C :includes <stdio.h> <malloc.h> :eval no :exports code
  int *p  = malloc(sizeof (int));
  printf("**p %l", **(int **)p);
#+end_src

In this case, we're saying "Hey, you know that integer pointer p?
Let's treat it as pointer to a pointer to an integer for right now".

***** ~sizeof (int *)~ vs ~sizeof (int)~

The last thing to remember deals with sizes. In 64-bit systems, a
pointer is 64-bits long, regardless of the type it points to. ~sizeof
int* == sizeof char* =​= sizeof double** =​= 8~. Using what we've
learned so far, let's say we have the following code block.

#+begin_src C :includes <stdio.h> <malloc.h> :eval no
  int *p = malloc(sizeof (int));
  ,*p = (int)p;
  printf("**p %d", **(int **)p);
#+end_src

We've managed to get everything right! Except for one little part.
~*p~ is an integer, not an integer pointer. We store the integer
pointer ~p~ in ~*p~. Because ~sizeof (int *) =​= 8~ and ~sizeof (int)
== 4~ (on my machine), part of the pointer is chopped off! ~p~ needs
to point to a type that is the same size (or larger) than an integer
pointer.[fn:2:Or any non-function pointer. There is no guarantee that
a function pointer is the same size as a integer/double/etc pointer,
and they're more of a abstraction that exists in our code than
something that's really "there", like integers in memory.]

The C standard actually includes an integer type that is guaranteed to
be the same size as a pointer, the signed ~intptr_t~ or unsigned
~uintptr_t~ types defined in =stdint.h=. I'll stay away from these
since I'm worried it'll make it a bit more confusing.

Time to put all of this into the most pointless (HAHAHAHAHA) practice
imaginable.

**** Circular pointers with ~malloc()~!

Let's take what we've learned and try to create a pointer that points
to itself, and one where we can dereference it as many times as we want!

#+begin_src C :includes <stdio.h> <malloc.h> :exports both
  int main(void) {
    long *p = malloc(sizeof (long *));
    ,*p = (long)p;  /* cast isn't required here */
    printf("p    0x%lx\n",  p);
    printf("*p   0x%lx\n",  *p);
    printf("**p  0x%lx\n",  **(long **)p);
    printf("***p 0x%lx\n",  ***(long ***)p);
  }
#+end_src

#+RESULTS:
| p    | 0x558366a4c2a0 |
| *p   | 0x558366a4c2a0 |
| **p  | 0x558366a4c2a0 |
| ***p | 0x558366a4c2a0 |

Look at that! We've successfully created a pointer that points to
itself! No matter how many times we dereference it, we are still
looking at the same pointer.

For fun, let's create a loop so we can deference the pointer as many
times as we want very easily.

#+begin_src C :includes stdio.h malloc.h :colnames '("i" "dereference") :exports both
  int main() {
    long *p = malloc(sizeof (long *));
    ,*p = (long)p;
    for (int i = 0; i < 5; i++) {
      long ptemp = *p;
      printf("%d 0x%lx\n", i, *p);
      p = (long *)ptemp;
    }
  }
#+end_src

#+RESULTS:
| i |    dereference |
|---+----------------|
| 0 | 0x55ffc15d32a0 |
| 1 | 0x55ffc15d32a0 |
| 2 | 0x55ffc15d32a0 |
| 3 | 0x55ffc15d32a0 |
| 4 | 0x55ffc15d32a0 |

And there we go. This is one option for how we can implement a pointer
that points to itself, no matter how many times we dereference it. If
we wanted to, we add more pointers, creating a circularly linked list
that looks like

#+begin_src mermaid :file static/static/mermaid-circular-pointer-list-example.png :theme neutral
graph LR
p1 ---> p2
p2 ---> p3
p3 --> p4
p4 --> p1
#+end_src

#+RESULTS:
[[file:static/static/mermaid-circular-pointer-list-example.png]]

**** Circular pointers with structs!

Another option that saves us from all this casting is to use structs.
Because a struct can contain anything[fn:3:Except for a struct
containing itself directly.], even a pointer to a struct of
the same type, we can do the following.

#+begin_src C :includes <stdio.h> :exports both
  struct p_self {
    struct p_self *p;
    int magic;
  };

  int main() {
    struct p_self p = { .p = &p, .magic = 4032 };
    printf("magic %d", p.p->p->p->p->p->magic);
  }
#+end_src

#+RESULTS:
: magic 4032

To my knowledge, we can't make ~p~ a pointer to a struct very
compactly. If we create a compound literal like

#+begin_src C :eval no
  struct p_self *p = &(struct p_self){ .p = /* problem */, .magic = 4032 };
#+end_src

we have a problem. The compound literal needs to contain a field that
contains it's own address. I don't believe it is possible to do this,
as there's no way to refer to the compound literal we are inside of.
(This could be avoided by not using compound literals and introducing
a second variable, but I'd rather not.)

Regardless, what we can conclude from this is that pointers are weird
and confusing and there's many little ways to mess up, especially as
we do increasingly weird stuff with them. But it's fun!

** TODO Calculating a Fourier series in C, visualising one with GNUPlot :@fourier:

*** Fourier Part 1: What is a Fourier series? :C:math:gnuplot:GSL:
:PROPERTIES:
:EXPORT_FILE_NAME: fourier_series_1
:EXPORT_DATE: 2021-04-06
:END:

#+begin_summary
In this post, I begin work on calculating a Fourier series using C. I
explain why one would use a Fourier series instead of a simpler
alternative, such as Taylor series. Additionally, I cover how we
can use the GNU Scientific Library, or GSL, to perform definite
integration.
#+end_summary

#+hugo: more


**** COMMENT Use ~#+hugo: more~ as a content divider when using summaries!

https://ox-hugo.scripter.co/doc/hugo-summary-splitter/

Don't trust what the [[https://gohugo.io/content-management/summaries/][official docs]] say. That only applies if I was
using Hugo to read the org file directly. (Which I think they support?
If it's not, that's a bug.

**** An overview of Taylor series

A fourier expansion is a way for us to approximate a function. If
you've taken calculus before, you may have heard of a similar concept,
Taylor series. With Taylor series, we can approximate any function as
a sum of polynomials. For example, we can write \( \sin x \) as

\[ \sin x = x - \frac{x^3}{3!} + \frac{x^5}{5!} - \frac{x^7}{7!} +
\cdots \]

If we were to graph this, ([[https://www.desmos.com][try it!]]), we see that as more terms are
added, our approximation becomes more and more accurate. Here's a
small demonstration.

#+begin_src gnuplot :file static/static/gnuplot-taylor-example.png :exports results
  set title "Taylor Example"
  set xtics nomirror
  set yrange [-3:3]
  set xrange [-8:8]
  set grid
  set key left top
  set xzeroaxis lt 1 lc "black" lw 1
  set yzeroaxis lt 1 lc "black" lw 1
  set size ratio 0.7

  fac(x) = (int(x)==0) ? 1.0 : int(x) * fac(int(x)-1.0)
  taylor(x, i) = (-1)**i * (x**(2*i+1)) / fac(2*i+1)

  plot sin(x) lw 3 title "sin(x)", \
       sum [i=0:2] taylor(x, i) lw 2 title '3 terms', \
       sum [i=0:4] taylor(x, i) lw 2 title '5 terms'
#+end_src

#+RESULTS:
[[file:static/static/gnuplot-taylor-example.png]]

In the graph below, I tried demonstrating how the Taylor series can
"home in" on a function. Since we can't add part of a term in a Taylor
series, I tried to demonstrate this effect by multiplying the term by
a value. For example, when you see 1.1 terms, that means the first
term + 0.1 * the second term. For \( \sin x \), that's \( x - 0.1 *
\frac{x^3}{3!} \)

#+begin_src gnuplot :file static/static/gnuplot-taylor-animated-example.gif :exports results
  # delay <time> has time in units of 1/100 seconds
  # default delay between frames. Each plot generates a frame
  set terminal gif animate delay 3 loop 0
  set title "Taylor Series Animation"
  set xtics nomirror
  set yrange [-3:3]
  set xrange [-8:8]
  set grid
  set key left top
  set xzeroaxis lt 1 lc "black" lw 1
  set yzeroaxis lt 1 lc "black" lw 1
  set size ratio 0.7
  set samples 400

  fac(x) = (int(x)==0) ? 1.0 : int(x) * fac(int(x)-1.0)
  taylor(x, n) = (-1)**n * (x**(2*n+1)) / fac(2*n+1)

  # plot sin(x) lw 3 title "sin(x)"
  do for [i=0:9] {
      inner_loops = 60
      do for [j=0:inner_loops] {
	  plot (1.0*j/inner_loops) * taylor(x, i) + sum [n=0:i-1] taylor(x, n)\
	       lw 2 title sprintf("%.1f term%s", i+1.0*j/inner_loops, i+1.0*j/inner_loops > 0 ? "s" : " ")
      }
      # Only way I can think of "pausing" the animation.
      do for [j=0:inner_loops/3] {
	  plot (1.0) * taylor(x, i) + sum [n=0:i-1] taylor(x, n)\
	       lw 2 title sprintf("%.1f term%s", i+1.0, i+1.0 > 1 ? "s" : " ")
      }
  } 
#+end_src

#+RESULTS:
[[file:static/static/gnuplot-taylor-animated-example.gif]]

Now, Taylor series can be useful, but they have significant
limitations. First, we see that the Taylor series does a poor job
modeling periodic functions. Even though \( \sin x \) repeats, our
Taylor series does not. At large \(x\) values, this Taylor series is
completely wrong!

Second, a Taylor series relies on the function being continuous (no
holes or jumps). In addition to the function being continous, its
derivatives must be as well. Let's consider the following graph.

#+begin_src gnuplot :file static/static/gnuplot-discontinuous-derivative.png :exports results
  set title "Discontinuous Derivative"
  set xtics nomirror
  set yrange [-3:3]
  set xrange [-8:8]
  set grid
  set key left top
  set xzeroaxis lt 1 lc "black" lw 1
  set yzeroaxis lt 1 lc "black" lw 1
  set size ratio 0.7

  set samples 1000

  f(x)  = x > 0 ? x : -1*x
  fp(x) = x < -0.01 ? -1 : x < 0.01 ? NaN : 1

  plot f(x) lw 2, fp(x) lw 2 title "fprime(x)"
#+end_src

#+RESULTS:
[[file:static/static/gnuplot-discontinuous-derivative.png]]

Even though \( f(x) \) is continuous, its derivative \( f'(x) \) is
not. As such, a Taylor series cannot be used to approximate this
function. This issue would come up even if \( f''''''''''(x) \) was
discontinuous. (Keep in mind that discontinuous is not the same thing
as 0! We can model \( f(x) = x \) as a Taylor series, as its
higher order derivatives are continuous. They just also happen to be
0. Also, \( f(x) = x \) is its own Taylor series.)

So, to summarize, Taylor series have the following issues

1. They do not model periodic functions well

2. They require the function and all of its derivatives to be
   continuous


Fortunately, the Fourier series provides answers to both of these
problems! (At least for most functions. Some functions, like a
function that is discontinuous everywhere, exist solely for the
purpose of making us sad.)

***** COMMENT Org misidentifying list

When a number appears at the start of a line followed by a period and
1. space like this, org mode will treat that as a list. This isn't a
perfect solution, but we can insert a non breaking space with ~C-q 240
ret~ after the period. Credit to Andrew Swann [[https://emacs.stackexchange.com/a/10422][here]].

**** What we're all here for, Fourier series

I'll be sticking to the basics of Fourier series for now. Let's assume
we have a periodic function \( f(x) \) that has a period of \( T \). I
am going to introduce the symbol \( l \) where \( l = \frac{T}{2} \)
While this isn't the only option, we can write the Fourier series as

\[ f(x) = \sum_{n=0}^{\infty} a_n \cos(\frac{n \pi x}{l}) + b_n
\sin(\frac{n \pi x }{l} ) \]

In this case, we can find \( a_n \) and \( b_n \) with the formulas

\[ a_n = \frac{1}{l} \int_{0}^{2l} f(x) \cos(\frac{n \pi x }{l}) dx \]

\[ b_n = \frac{1}{l} \int_{0}^{2l} f(x) \sin(\frac{n \pi x }{l}) dx \]

I won't go into detail as to where these formulas come from. (That is
left as an exercise for the reader. Hah!) However, I will point out
that we can adjust the limits of integration to any values we want,
just as long as the difference between the upper and lower limits
equals our period.

There is one special case that we need to discuss. When \( n = 0 \),
we need a new formula for \( a_0 \). This formula will look like

\[ a_0 = \frac{1}{2l} \int_{0}^{2l} f(x) dx \]

Fortunately there is no special case for \( b_0 \). This occurs due to
the fact that \( a_0 \) is a constant term ( \( \cos 0 = 1 \) as
opposed to periodic.

That is all the theory that we need to calculate the Fourier series!
As long as we can find a library that can perform integration for us,
we should be able to calculate the Fourier series for any periodic
function.

**** Using GSL to calculate an integral

***** Explanation of ~gsl_integration_qng()~

Because of inscrutible magic mumbo jumbo, I decided to use C for
calculating the Fourier expansion. In order to do that, I needed to
pick out a library that could perform the integration for me. I
settled on =GSL= or the GNU Scientific Library. There are many, many,
MANY functions available in this library, but luckily I only need to
worry about integration.

Before going too far into Fourier stuff, I'm going to do a simple
sanity check so I can make sure I'm calculating integrals correctly. I
want to calculate the following integral.

\[ \int_{0}^{8} x dx \]

To do this using =GSL=, I can use the ~gsl_integration_qng()~
function. This function has the following signature.

#+begin_src C :eval no
  int gsl_integration_qng(const gsl_function * f,
			  double a, double b,
			  double epsabs, double epsrel,
			  double * result, double * abserr,
			  size_t * neval)
#+end_src

~f~ is a pointer to a structure that contains a function pointer. For
those who don't speak nerd, this is how ~gsl_integration_qng()~ knows
what function to integrate. It's our ~f(x)~. (Mostly. The reason for
making it a structure is because the structure also contains a ~void
*~ or void pointer. This void pointer can be used to pass parameters
to the function. This could be used to let us change the slope of the
function without having to modify the function itself.

~a~ and ~b~ are the lower and upper limits of integration. That's
fairly straightforward.

~epsabs~ and ~epsrel~ help ~gsl_integration_qng()~ decide when to stop
integrating. It's not possible to integrate the function to an exact
value with =GSL=. Instead, it tries to zero in on a specific value or
best guess as to what the answer is. ~epsabs~ is the absolute error
that we want. If ~epsabs~ = 0.1, we don't know what the answer is, but
we know we are no more than 0.1 away from it. ~epsrel~ is similar, but
percentage based instead of absolute. (e.g. ~epsrel~ = 0.01 means our
answer is within 1% of the actual value.)

~result~ and ~abserr~ are used by the function to store the result
and estimated absolute error, respectively. The number of iterations
it took to calculate the result is stored in ~neval~.

It is possible for the integration to fail. This might happen if we
set the error tolerances too tight. Since the function we're
integrating is so simple, I don't think that's a likely concern.

***** ~gsl_integration_qng()~ in use

To compile this program, you will need to tell the compiler what
external libraries to use. You can do with with the ~-lgsl~ compile
flag, e.g. ~gcc main.c -lgsl~. Because =GSL= depends on another
library, =CBLAS=, you will also need the ~-lcblas~ flag. If =CBLAS=
isn't available, you can use a version of =CBLAS= provided by =GSL=
with ~-lgslcblas~. (Don't forget to install =GSL=!) Since I'm using
some math function, I'm also going to include the math library with
~-lm~.

In the end, our command will look like ~gcc main.c -lgsl -lcblas -lm~,
which will compile =main.c= and create an output file =a.out=.
(Actually I'm using =org-babel= so I don't have to deal with this, but
I'm assuming most readers here are not.)

Alright! Time to integrate! I need to preface the =gsl_integration.h=
header with =gsl/= as the headers are installed in a =gsl=
subdirectory. (If you installed this through your systems package
manager, you can probably find this file in =/usr/include/gsl/=.)

#+begin_src C :libs -lgsl -lcblas -lm :eval no-export :exports both
  #include <stdio.h>
  #include <gsl/gsl_integration.h>
  #include <math.h>

  /* This is where we define the function */
  double f(double x, void *params) {
    return x;
  }

  int main() {
    double result, error;
    double low = 0, high = 8;
    gsl_function F = {.function = &f};
    double err_abs = 0, err_rel = 1;
    size_t num_evals;

    gsl_integration_qng(&F, low, high, err_abs, err_rel,
			&result, &error, &num_evals);
    printf("result error num_evals\n");
    printf("%f %f %zu\n", result, error, num_evals);
  }
#+end_src

#+RESULTS:
| result | error | num_evals |
|   32.0 |   0.0 |        21 |

There we go! =GSL= was able to successfully integrate \( \int_{0}^{8}
x dx \).

In the next part, we'll start using =GSL= to calculate the Fourier
series of a discontinuous, periodic function. We'll see if we can
naively get away with using the simple ~gsl_integration_qng()~
function, or if we need to find a more complicated, but more powerful, alternative.

*** DONE Fourier Part 2: Integrating a discontinuous function :C:math:gnuplot:GSL:
CLOSED: [2021-04-12 Mon 13:48]
:PROPERTIES:
:EXPORT_FILE_NAME: fourier_series_2
:EXPORT_DATE: [2021-04-10 Sat]
:END:


#+begin_summary
In this post, I look at how we can integrate a discontinuous function.
I explain how we can use GSL to perform integration even when there is
a discontinuity. Afterwards, I finally calculate the Fourier series
for a discontinuous periodic function.
#+end_summary

#+hugo: more

#+begin_comment
Can't have _ or ~code~ in summary sections. ~code~ isn't processed
(left as `), and underscores are escaped.
#+end_comment

**** Checking if ~gsl_integration_qng()~ will work

At the end of [[*Fourier Part 1: What is a Fourier series?]], I suggested
that ~gsl_integraton_qng()~ would not be able to successfully
integrate the function we want to find the Fourier series of. Here is
the function I will find the Fourier series of.

#+begin_src gnuplot :file static/static/gnuplot-fourier-function-orig.png
  set title "Original Function"
  set xtics nomirror
  set grid
  set xrange [-8:8]
  set yrange [-2:6]
  set yzeroaxis lw 2
  set xzeroaxis lw 2
  set samples 1500
  set size ratio 0.7
  f(x) = (x - 4 * (floor(x/4) % 4) > 3.99) ? NaN : \
       x - 4 * (floor(x/4) % 4)
  plot f(x) lw 2 lc rgb "#009e73" notitle
#+end_src

#+RESULTS:
[[file:static/static/gnuplot-fourier-function-orig.png]]

Because this function is discontinuous, we have to approximate it with
a Fourier series instead of a Taylor series. If we recall the formulas
shown in the last part, we know that we will have to integrate \( f(x)
\) from \( 0 \) to \(2l\), among other things. Before calculating the
Fourier series, let's try using ~gsl_integration_qng()~ to perform
basic integration.

#+begin_src C :libs -lgsl -lcblas -lm :exports both
  #include <stdio.h>
  #include <math.h>
  #include <gsl/gsl_integration.h>

  /* f(x) = x for 0 <= x < 4, repeating */
  double f(double x, void *params) {
    const double period = 4;
    return fmod(x, period);
  }

  int main() {
    double result, error;
    double low = 0, high = 8;
    gsl_function F = {.function = &f};
    double err_abs = 0, err_rel = 1;
    size_t num_evals;

    gsl_integration_qng(&F, low, high,
			err_abs, err_rel,
			&result, &error, &num_evals);
    printf("result error num_evals\n");
    printf("%f %f %zu\n", result, error, num_evals);
  }
#+end_src

#+RESULTS:
|    result |    error | num_evals |
| 14.804436 | 8.015135 |        21 |

Well, something happened here, but it's not quite what we wanted. We
told =GSL= to take \( \int_0^8 f(x) dx \). Since we're dealing with a
discontinuous function, we can rewrite this as \( \int_0^4 x dx +
\int_4^8 x dx \) Now I'm no mathematician, but this answer should be
16, not 14.8. Additionally, our error is very large, and if I attempt
to lower ~err_rel~ to a smaller value, =GSL= yells at me saying that
it failed to reach the requested error.

This is not a problem on =GSL='s end. We aren't using the right
integration function for the job! According to the =GSL= manual,

#+begin_quote
The QNG algorithm is a non-adaptive procedure which uses fixed
Gauss-Kronrod-Patterson abscissae to sample the integrand at a maximum
of 87 points. It is provided for fast integration of smooth functions.
#+end_quote

While that's a lot of words, the important part is the last sentence.
~gsl_integration_qng()~ is for smooth functions. Our function is not
smooth, it has a discontinuity! We will need to find an alternative
function in =GSL= that can handle discontinuous graphs.[fn:1:Strictly
speaking, this isn't actually true. Because the discontinuity occurs
at the limits of integration for our function (as long as we only integrate
from 0 to 4), we can use ~gsl_integration_qng()~. Not all functions
are like this, so it's still best to find an alternative.]

**** ~gsl_integration_qag()~ and discontinuities

Fortunately we do not have to look far. The very next function
mentioned in the [[https://www.gnu.org/software/gsl/doc/html/integration.html][manual]] is what we need. ~gsl_integration_qag()~ has
the following signature.

#+begin_src C
  int gsl_integration_qag(const gsl_function * f,
			  double a, double b,
			  double epsabs, double epsrel,
			  size_t limit, int key,
			  gsl_integration_workspace * workspace,
			  double * result, double * abserr)
#+end_src

~f~, ~a~, ~b~, ~epsabs~, ~epsrel~, ~result~, and ~abserr~ are all the
same as ~gsl_integration_qng()~. We can see that several new terms are
introduced however.

~workspace~ is a pointer to an area of memory used by
~gsl_integration_qag()~. We allocate space by using the
~gsl_integration_workspace_alloc()~ function, This function is passed
an integer to adjust how much memory we want to allocate. Whatever
integer we pass to ~gsl_integration_workspace_alloc()~,  we need to
ensure that ~limit~ is the same. This way, ~gsl_integration_qag()~
knows how much memory it has available.

~key~ is a integer between 0 through 6. =GSL= recommends using higher
values when integrating smooth functions, and lower values when
functions are discontinuous.

Let's see how well ~gsl_integration_qag()~ performs!

#+begin_src C :libs -lgsl -lcblas -lm :exports both
  #include <stdio.h>
  #include <math.h>
  #include <gsl/gsl_integration.h>

  double f(double x, void *params) {
    const double period = 4;
    return fmod(x, period);
  }

  int main() {
    size_t limit = 1024;
    gsl_integration_workspace *w
      = gsl_integration_workspace_alloc(limit);
    double result, error;
    double low = 0, high = 8;
    gsl_function F = {.function = &f};
    double err_abs = 0, err_rel = 1e-7;

    gsl_integration_qag(&F, low, high,
			err_abs, err_rel,
			limit, 1, w,
			&result, &error);
    /* get into the habit of freeing memory when done! */
    gsl_integration_workspace_free(w);
    printf("result error\n");
    printf("%f %f\n", result, error);
  }
#+end_src

#+RESULTS:
| result | error |
|   16.0 |   0.0 |

Look at that! We are getting the exact value we expected, even though
we're integrating with a discontinuity. We are now at the point where
we can calculate the Fourier series for our function.


**** Generating our Fourier series

Let's recall that we can find our \(a_n\) and \(b_n\) coefficients
with the following formulas.

\[ a_n = \frac{1}{l} \int_{0}^{2l} f(x) \cos(\frac{n \pi x }{l}) dx \]

\[ b_n = \frac{1}{l} \int_{0}^{2l} f(x) \sin(\frac{n \pi x }{l}) dx \]

=GSL= expects us to only pass one function to it as an argument. That
means that, unlike before, we can't just pass a pointer to our function
~f(x)~, as =GSL= won't be multiplying it by the cosine and sine terms.

There are a couple of solutions to this that I can think of. The first
is to make use of the ~void *~ argument that =GSL= includes in the
~gsl_function~ structure. Using this, we could pass extra information
to ~f(x)~, adapting it to our specific n value.

Alternatively, we could write a parent function, like ~aorb_subn()~. This
function would then be stored in the ~gsl_function~ structure. The
advantage of this approach is that the function we want the Fourier
series of, ~f(x)~, is distinct in our code. This should make it a bit
easier to change ~f(x)~ to any function that we want. This is the
approach that I will take.

To make this code hopefully a bit more modular, I moved the
integration out of main, and instead into a function called
~get_aorb_subn()~. This function calculates the nth Fourier
coefficient for a function ~f(x)~, using the variable ~get_a~ to
determine if it should calculate \( a_n \) or \( b_n \). It may be
better to wrap this in a ~fourier~ structure that contains the two
terms, but I elected not to do that to hopefully maintain some vague
semblance of readability.

This is what the code to calculate the Fourier series looks like.

#+begin_src C :libs -lgsl -lgslcblas -lm :colnames '("n" "a_subn" "b_subn") :exports both
  #include <stdbool.h>
  #include <stdio.h>
  #include <math.h>
  #include <gsl/gsl_integration.h>

  #define PI 3.14159
  const double period = 4;
  const double l = period / 2;

  struct aorb_params {
    double (*f)(double x, void *params);
    int n;
    bool calc_a;
  };

  double f(double x, void *params) {
    return fmod(x, period);
  }

  double aorb_subn(double x, struct aorb_params *params) {
    int n = params->n;
    double trig = params->calc_a ? cos(PI*n*x/l) : sin(PI*n*x/l);
    return params->f(x, NULL) * trig;
  }

  double get_aorb_subn(double (*f)(double x, void *params), int n, 
		       double low, double high, bool get_a) {
    double normalization = 1/l;
    if (get_a && n == 0) normalization /= 2;

    size_t limit = 1024;
    gsl_integration_workspace *w
      = gsl_integration_workspace_alloc(limit);
    double result, error;
    gsl_function F = { .function = &aorb_subn,
      .params = &(struct aorb_params){ .f = f, .n = n,
			 .calc_a = get_a } };
    double err_abs = 0, err_rel = 1e-7;

    gsl_integration_qag(&F, low, high,
			err_abs, err_rel,
			limit, 1, w,
			&result, &error);
    gsl_integration_workspace_free(w);

    return normalization * result;
  }

  int main() {
    const int upto = 10;
    double a_subn[upto], b_subn[upto];
    double low = 0, high = period;

    for (int i = 0; i < upto; i++) {
      a_subn[i] = get_aorb_subn(f, i, low, high, true);
      b_subn[i] = get_aorb_subn(f, i, low, high, false);
      printf("%d %f %f\n", i, a_subn[i], b_subn[i]);
    }
  }
#+end_src

#+NAME: tbl-fourier-asubn-bsubn
#+RESULTS:
| n | a_subn |    b_subn |
|---+--------+-----------|
| 0 |    2.0 |       0.0 |
| 1 | -7e-06 | -1.273242 |
| 2 | -7e-06 | -0.636621 |
| 3 | -7e-06 | -0.424414 |
| 4 | -7e-06 |  -0.31831 |
| 5 | -7e-06 | -0.254648 |
| 6 | -7e-06 | -0.212207 |
| 7 | -7e-06 | -0.181892 |
| 8 | -7e-06 | -0.159155 |
| 9 | -7e-06 | -0.141471 |

#+begin_comment
*GNUPlot fails to generate graph on export*

I suspect the issue here is that the data table is not available on
export. To fix this for right now, I am now executing the C block on
export. This isn't a sustainable solution since it requires the
libraries to be present on any server.

I found a better solution. Manually give the table a name.
#+end_comment

Like I mentioned before, ~aorb_subn~ is a "parent function" that
combines ~f(x)~ and the sine/cosine term. This is the function we
integrate, and we provide it enough information to know what term we
are calculating.

Interestingly, if we use the \( \pi \) constant ~M_PI~, the integration
fails due to roundoff error. Fortunately we can get "close enough"
values by just using a few less digits.

Once we graph the Fourier series generated by these coefficients, this
is what we get.

#+begin_src gnuplot :var data=tbl-fourier-asubn-bsubn :file static/static/gnuplot-asubn-bsubn.png :exports results
  set title "Fourier Series"
  set xtics nomirror
  set yrange [-2:6]
  set xrange [-8:8]
  set grid
  set yzeroaxis lw 2
  set xzeroaxis lw 2
  set size ratio 0.7
  set samples 200
  getValue(row,col,filename) = system('awk ''{if (NR == '.row.') print $'.col.'}'' '.filename.'')
  fourier(x, n) = getValue(n+1, 2, data) * cos(pi*n*x/2) + getValue(n+1, 3, data) * sin(pi*n*x/2)
  # todo automatically iterate # rows in table
  plot sum [n=0:9] fourier(x, n) notitle
#+end_src

#+RESULTS:
[[file:static/static/gnuplot-asubn-bsubn.png]]

And there we are! Here is a Fourier series generated for a discontinuous
periodic function. The more terms we add, the more accurate the
approximation.

** TODO stm8-card						  :@stm8_card:

*** COMMENT Outline

- I would like to cover the following

  - Dependencies (mermaid graphs), both what I current have and what I
    want to turn it into

  - My implementation of 256 byte framebuffer for 512 byte display

  - Issues that came up during development

    - Not remaking compilation units properly when changing function
      prototypes (commit 360dc35)

      - Compiled main with int arguments to ~i2c_send_bytes()~,
        changed in ~char~ in i2c.h, but main wasn't recompiled. Fixed
        with ~$ make clean~.

      - Also present in 170cf61

      - Would like to adjust makefile to
        automatically recompile based on dependencies / includes

    - Undefined behavior with overflow in ~space_invader.c~
      ~player_laser_tick()~. If statement right before return (present
      in commit 881c70c) overflows, relying on undefined behavior that
      overflow of signed char goes to < 0

    - Baud rate of UART, 80x less than what was expected (double check numbers)

      - HSI prescaler fixed the problem, supposedly divided clock to uart
        by factor of 8 (16 mhz -> 2 mhz), further divided by BRR1 and
        BRR2 to 9600 baud rate

	- But my baud rate was off by a factor of 80, not 8. There's a
          factor of 10 I can't account for

    - Limitations of sdcc, no passing structures directly, only pointers

      - No compound literals making initialization of nested
        structures ugly

    - Packing of structures, see comment in ~space_invader.c~ line
      18-30 in commit 881c70c

    - Padding in memory map, see commit 63ad629

      - No functional purpose I could find, takes almost 1% of my heap
        / static memory!

*** TODO stm8-card: Dependencies
:PROPERTIES:
:EXPORT_FILE_NAME: stm8-card-deps
:END:

Ideally, the dependencies would look like this.

~baseline~ is meant to represent a collection of useful macros and
maybe functions. (e.g. ~SIZEOFARRAY()~, ~CONTAINER_OF()~, etc)

~hal~ and ~stm8_board_lib~ are libraries that would be formed from
combining several pieces. The ~hal~ is a hardware abstraction library,
providing a consistent API that any code I write can use. I can "slot
in" any board lib, like the ~stm8_board_lib~, to port the code to a
different microcontroller. This will require a *lot* of restructuring
of the component pieces (~uart~. ~i2c~, etc).

#+begin_src mermaid :file static/static/mermaid-stm8-card-dep-graph.png :theme neutral :background_color transparent :exports results
graph TD;

main --- space_invader & ssd1306 & baseline & hal

space_invader & ssd1306 --- image

hal --- stm8_board_lib
stm8_board_lib --- gpio & i2c & registers & ...
#+end_src

#+RESULTS:
[[file:static/static/mermaid-stm8-card-dep-graph.png]]

Currently, they look something like this. (Double check and remake if
needed, going off of memory) [2021-03-26 Fri]

#+begin_src mermaid :file static/static/mermaid-stm8-card-dep-graph-current.png :theme neutral :background_color transparent :exports results
graph TD;

main --- space_invader & ssd1306 & baseline & i2c & uart & image

ssd1306 --- i2c & uart & baseline & image
space_invader --- image & baseline
image --- baseline
baseline --- registers
blink_code --- baseline & registers & gpio

i2c --- registers & baseline
uart --- registers

#+end_src

#+RESULTS:
[[file:static/static/mermaid-stm8-card-dep-graph-current.png]]

*** TODO stm8-card: Frame Buffers
:PROPERTIES:
:EXPORT_FILE_NAME: stm8-card-frame-buffer
:END:

#+begin_summary
Here I explain how I solved a challenging issue related to memory
limitations in my PCB business card. 
#+end_summary

#+hugo: more

**** Background

I recently designed and fabricated a printed circuit board (PCB)
business card. I used a STM8S003F3 microcontroller along with a
SSD1306 display. This business card has my name, contact info, and
other information on a silkscreen layer. The microcontroller runs a
"space-invaders-esque" game, communicating with the display over I2C.

You can view the code and board files [[https:gitlab.com/rjsent/stm8_card][here]].

The most natural way to control a display is to create what's called a
/frame buffer/. We would allocate enough space in the microcontrollers
memory so that every pixel is 1 bit. Every time we want to change the
display, we can just set or reset bits in the frame buffer, and then
transmit the entire frame buffer.

However, eight bit microcontrollers are very resource limited. My display's
dimensions are 128x32, or 4096 pixels. If I used 1 bit to represent
each pixel, I will use 512 bytes of RAM. The microcontroller I'm
using has 1024 bytes.

This doesn't sound so bad, right? I have over twice the memory needed
for my frame buffer! Well, there's a /slight/ issue.

Of those 1024 bytes, 512 are reserved for the /stack/. The stack keeps
track of where we are in the program, local variables that are in use,
and similar. As you might expect, that means the stack is
*absolutely essential*. We obviously can't chop out the entire stack
for our frame buffer. It's possible to only store part of our frame
buffer where the stack is, but it's challenging to determine how much
of the stack is in use at any time. The stack could overwrite part of
our frame buffer as we jump between functions, which would corrupt our
display into a mess of pixels.

Okay, so we went from having 1024 bytes of memory in the microcontroller to 512.
That's still enough for our frame buffer, so what's the big deal?
Well, I need to store more stuff than just the frame buffer outside of
the stack. The space invaders code (=space_invaders.c=) has several
/statically allocated/ variables. That means these variables are not
stored in the stack, but in that 512 bytes area. (It works out to
about 176 bytes.)

Now we're down to 336 bytes, which somehow needs to represent 512
bytes of data. Sounds like a problem, doesn't it?

**** Making due with less, drawing a display without a complete frame buffer

So creating a 512 byte frame buffer is a bust. Fortunately though,
there are some ways I could work around this! One option, and the one
I went with, was to only draw half the display at a time! I
created a function in =ssd1306.h= with the following signature.

#+begin_src C :eval no
  /* I dunno if an enum is the best way to do this, but I'm doing it! */
  typedef enum { RIGHT, LEFT } ssd1306_side_t;
  /* ... */
  /* Draw the frame buffer to the selected side */
  signed char draw_half(ssd1306_side_t side);
#+end_src

Let's take a look at how ~draw_half()~ works, shall we?

#+begin_src C :eval n
  signed char draw_half(ssd1306_side_t side) {
    const uint8_t change_start_right[7] = {CONTROL_BYTE(CO_DATA, DC_COMMAND),
      CMD_ADDR_COL, SSD1306_WIDTH / 2, SSD1306_WIDTH - 1,
      CMD_ADDR_PAGE, 0, 3};
    const uint8_t change_start_left[7] = {CONTROL_BYTE(CO_DATA, DC_COMMAND),
      CMD_ADDR_COL, 0, SSD1306_WIDTH / 2 - 1,
      CMD_ADDR_PAGE, 0, 3};
    int err;
    if (side == RIGHT) {
      err = send_data(change_start_right, sizeof(change_start_right) / sizeof(change_start_right[0]));
    } else {
      err = send_data(change_start_left, sizeof(change_start_left) / sizeof(change_start_left[0]));
    }
    if (err != 0) return err;

    draw_frame_buffer();
    return 0;
  }
#+end_src

I have two arrays with 7 bytes of data in them called
~change_start_right~ and ~change_start_left~. When ~draw_half(LEFT)~
is called, I send ~change_start_left~ to the display, and vice versa.
[fn:4:That ~sizeof~ nonsense lets me add and remove elements to
~change_start_*~ without needing to change the second argument to
~send_data()~.] When ~change_start_left~ is sent, the pixel
addressing looks like

[[file:static/static/stm8-card-addressing-left.png]]

and when ~change_start_right~ is sent

[[file:static/static/stm8-card-addressing-right.png]]

Obviously this is a little scaled down compared to a 128x32 pixel
display, but it illustrates the point. The first bit of my frame
buffer is sent to the top left of the half we are on, then we move
across horizontally until reaching the halfway point. We then jump
down a row and repeat!

For completeness, ~draw_frame_buffer()~ looks like

#+begin_src C :eval no
  struct S {
    uint8_t control_byte;
    uint8_t frame_buffer[BUF_SIZE];
  } SSD1306_Data = {.control_byte = CONTROL_BYTE(CO_DATA, DC_DATA)};
  /* ... */
  signed char draw_frame_buffer() {
    return send_data(&SSD1306_Data.control_byte, sizeof(struct S));
  }
#+end_src

Every transmission needs to start with a control byte. I can't start a
transmission, send a control byte, stop it, start a new one, and send
the frame buffer. It needs to be one continuous message.
~send_bytes()~ (which is just a wrapper for ~i2c_send_bytes()~) takes
an array of data and a size, and will just send that array over. In
other words, I can't tell ~i2c_send_bytes()~ "Hey, send this byte
first, then send these 256 bytes".

I could make ~frame_buffer~ a 257 byte array, and remember that the
first byte represents the control byte, not pixels. This is an ugly
solution in my eyes and will complicate later code. Instead,
remembering that an array is just a block of continuous memory, I
found a second solution. I created a structure with the control byte
first, followed by the frame buffer. The elements in a structure are
continuous [fn:5:Sorta. There is something called structure "padding".
However, since I'm dealing with 8 bit data in an 8 bit
microcontroller, it's not an issue. Even if that wasn't enough, the
fact that everything is 8 bits or an array of 8 bit elements, padding
won't be added. /Technically/ though I don't know if the C standard
guarantees this. Some compilers support structure "packing" with a
compile-time flag, which is guaranteed to prevent this issue. I am
using SDCC, which does not.], so to ~send_bytes()~, this is just a 257
byte array.

*** TODO stm8-card: Part 1
:PROPERTIES:
:EXPORT_FILE_NAME: stm8-card-1
:END:

* Local Variables						   :noexport:
Local Variables:
org-footnote-define-inline: t
End:
