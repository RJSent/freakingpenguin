#+AUTHOR: Richard Sent
#+HUGO_BASE_DIR: ./
#+HUGO_FRONT_MATTER_KEY_REPALCE: post>posts
#+PROPERTY: header-args:mermaid :eval yes
#+PROPERTY: header-args:gnuplot :eval yes
#+PROPERTY: header-args         :eval no-export

* Homepage
:PROPERTIES:
:EXPORT_HUGO_SECTION: /
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_MENU: :menu "main"
:END:

This is the home of my blog!

* About
:PROPERTIES:
:EXPORT_FILE_NAME: about
:EXPORT_HUGO_SECTION: /
:END:

Hi there! I am an undergraduate student double majoring in Computer Engineering
and Physics at Cleveland State University.

Outside of taking super heavy course loads, I enjoy spending my free
time tinkering with technology. Often this means low-level
development, such as with ST microcontrollers.

I've done undergraduate research with the physics department at CSU,
even managing to combine my two degrees into a useful project! You can see
the source code for that project [[https:gitlab.com/rjsent/usra_video][here]].

I have experience with the following programming languages and tools:

- C

- Ruby

- Java

- VHDL

- Git

- Linux

  - [[https://www.gnu.org/gnu/incorrect-quotation.en.html][I'd just like to interject for a moment...]]

- Emacs / Emacs Lisp

- Nginx

  - This website is hosted on a virtual private server using Nginx!

- Hugo
  
Some general topics I find interesting are:

- Embedded development

- Hardware design and FPGAs

- Security

- Quantum Computing

- Systems Programming

- Open Source Software/Hardware

  - Here's hoping the PinePhone keeps succeeding!


Aside from that, I work to ensure that I'm not just learning the
syntactical grammar of a programming language, but also the underlying
concepts and good development practices. /Practical Object Oriented
Design/ by Sandi Metz provides an excellent overview from an
object-oriented standpoint, and I feel many of the core principles can
be applied to procedural languages like C. Maybe I'll write a post on this
once I finish /C Interfaces and Implementions/ by Hanson.

*** COMMENT Gitlab link issue

See https://github.com/kaushalmodi/ox-hugo/issues/236 for a more
detailed discussion on the issue and potential fix. I left a comment
since Hugo now uses Goldmark instead of Blackfriday by default, so the
Blackfriday bug should not be relevent.

** Personal

Outside of programming and physics, I enjoy the following:

- Camping and hiking

- Reading, both for education and recreation

- Traveling

- Cats

- Learning about new cultures

* TODO Projects

- List of projects, ala https://www.thomasvanderberg.nl/projects/

* Posts
:PROPERTIES:
:EXPORT_HUGO_SECTION: posts
:END:

** Blog Homepage
:PROPERTIES:
:EXPORT_HUGO_MENU: :menu "main"
:EXPORT_FILE_NAME: _index
:END:

Man, look at all my blog posts.

** COMMENT Testing ox-hugo
:PROPERTIES:
:EXPORT_FILE_NAME: testing-ox-hugo
:EXPORT_DATE: 2021-03-24
:END:

This is some text.

Here is an inline equation! \( F = ma \)

Here is an equation with the square brackets.

\[ \lambda = \frac{4309248302}{a_4 785494} \]

Here's a source block

#+begin_src C :includes stdio.h
  printf("Hello world!");
#+end_src

#+RESULTS:
: Hello world!

*** And here is a subheading!

With some text underneath!

*** Another one!

[[file:static/static/another_one.jpg]]

** Musings :@musings:

*** Are bus errors still commonplace? Plus a bonus discussion on =org-babel=. :C:low_level:org:babel:
:PROPERTIES:
:EXPORT_FILE_NAME: bus_errors_1
:EXPORT_DATE: 2021-03-24
:END:

I was reading through Peter Linden's /Expert C Programming/ when I noticed
an interesting example. On page 189, Peter talks about how one can
cause a bus error. I've never had a bus error occur before. Maybe
they're a solved problem?

Before we get too far ahead of ourselves, a bus error can occur when
we access a variable at an address that's not valid for that variable.
An address is not valid if the address is not evenly divisible by the
length of the variable. In other words...

#+begin_src C :exports code
  /* sizeof (int) == 4 */
  int p1 = *(int *) 5;
  /* Causes a bus error, 5 % 4 != 0 */

  int p2 = *(int *) 32;
  /* No bus error, 32 % 4 == 0 */
#+end_src

Realistically these programs would immediately seg fault as we
don't have access to arbitrary memory addresses. (Unless we were
working with embedded systems, perhaps...). To avoid this, we
can use a union.

**** Peter Linden's Code

Using the sample code in /Expert C Programming/, pg.
189, I am going to see if it causes a bus error.

The address of the union must be divisible by 4 (or ~sizeof int~),
as it can store an integer. As long as ~sizeof int < sizeof char~
(or ~sizeof int > 1~ as ~sizeof char == 1~), we can successfully
get our bus error.


#+begin_src C :includes stdio.h :exports both
  union {
    char a[10];
    int i;
  } u;
  int *p = (int *) &(u.a[1]);
  ,*p = 17;
  printf("*p %d\n", *p);
#+end_src

#+RESULTS:
: p 17

Look at that! No problems. 

x86 is very forgiving when it comes to misalignment errors. For the
most part, they just don't happen. This is great for us, but what if
we ported this code over to a platform that is less friendly, like
ARM?

Ideally, we want to see if a bus error /can/ occur in our code, so
that way we can avoid them during development, as opposed to fixing it
later.

Looking through the =gcc= manual, I found a compile flag that will be
useful.

#+begin_quote
~fsanitize=undefined~

Enable UndefinedBehaviorSanitizer, a fast undefined behavior detector.
Various computations are instrumented to detect undefined behavior at
runtime.
#+end_quote

By adding the ~-fsanitize=undefined~ compile flag, our program will
print a runtime error whenever one occurs.

There are similar flags, ~-fsanitize=address~ and ~-fsanitize=thread~,
that can be useful for runtime error checking; look at the =gcc=
manual for more information. I can combine options with commas, i.e.
~-fsanitize=address,thread,undefined~.

**** ~-fsanitize=undefined~

There is one change that I need to make to the code. When a runtime
error occurs, the results are printed to =stderr=. When we're looking
at our code through a terminal, =stderr= and =stdout= might seem like
the exact same thing.

I am not running this code through a terminal. I'm using =org-babel=,
a very powerful tool for literate programming. If our
program runs successfully, =org-babel= will tell us the results.

Unfortunately, these results don't include =stderr=. In order to see
the runtime error occur, I need to close =stderr=, then change
=stderr='s file descriptor to point to =stdout=. This is what the
~dup2()~ function is doing.

#+begin_src C :includes stdio.h unistd.h :flags -Wall -fsanitize=undefined :results verbatim :exports both
  dup2(STDOUT_FILENO, STDERR_FILENO);

  union {
    char a[10];
    int i;
  } u;
  int *p = (int *) &(u.a[1]);
  ,*p = 17;
  printf("*p %d\n", *p);
  printf("p %lld\n", p);
#+end_src

#+RESULTS:
#+begin_example
/tmp/babel-YOFYnN/C-src-93AiCJ.c:17:6: runtime error: store to misaligned address 0x7ffec796bddd for type 'int', which requires 4 byte alignment
0x7ffec796bddd: note: pointer points here
 40 5a 14 84 55 00 00  e0 be 96 c7 fe 7f 00 00  00 f5 9a c3 4a 31 08 2e  00 00 00 00 00 00 00 00  25
             ^ 
/tmp/babel-YOFYnN/C-src-93AiCJ.c:18:3: runtime error: load of misaligned address 0x7ffec796bddd for type 'int', which requires 4 byte alignment
0x7ffec796bddd: note: pointer points here
 40 5a 14 84 11 00 00  00 be 96 c7 fe 7f 00 00  00 f5 9a c3 4a 31 08 2e  00 00 00 00 00 00 00 00  25
             ^ 
,*p 17
p 140732246965725
#+end_example

And it works! We can now see the runtime error! We're trying to access
an integer at address 140732246965725, which is not divisible by 4
(AKA ~sizeof int~). Thus, a bus error occurs.

**** Crash and burn programming

Running code and printing out runtime errors is great. However, there's a
saying in programming called "Fail early, fail often". What if we
don't just want an error message printed? What if, instead, we want
the program to immediately crash? After all, this is what would
actually happen if we were on a CPU architecture that couldn't handle
misaligned addresses.

I looked through the =gcc= manual and saw the ~-fno-sanitize-recover=all~
option. Supposedly, it does the following:

#+begin_quote
~-fsanitize-recover=all~ and ~-fno-sanitize-recover=all~ is also accepted,
the former enables recovery for all sanitizers that support it, the
latter disables recovery for all sanitizers that support it.
#+end_quote

Let's try it! I'm going to add ~-fno-sanitize-recover=all~ as a
compile flag. This should cause the program to immediately crash,
only printing the error message.

#+begin_src C :includes stdio.h unistd.h :flags -Wall -fsanitize=undefined -fno-sanitize-recover=all :results verbatim :exports both
  dup2(STDOUT_FILENO, STDERR_FILENO);

  union {
    char a[10];
    int i;
  } u;
  int *p = (int *) &(u.a[1]);
  ,*p = 17;
  printf("p %d\n", *p);
#+end_src

#+RESULTS:

Huh? Why wasn't the error message printed? Crashing the program is
what we wanted, but not without the error message! Without an error
message, all we're doing is making our program harder to debug.

Fortunately, this isn't our fault. The error message is actually being
printed, and it is being printed to =stdout=. If we were running our
program in a terminal, we'd see the error message we expect.

Unfortunately, this is a limitation of =org-babel=.
~-fno-sanitize-recover=all~ causes a nonzero exit code to be returned
on failure. =org-babel= does not like nonzero exit codes and fails to
evaluate ~stdout~ when this happens. It does evaluate ~stderr~ when
the exit code is nonzero, but only to a separate temporary buffer. At
least this works outside of =org-babel=.

There's a (brief) discussion of this issue on the mailing list [[https://lists.gnu.org/archive/html/emacs-orgmode/2016-05/msg00204.html][here]].
Given that this thread is 5 years old, I'm not holding my breath for a
fix.

There is an easy solution for ~sh~ scripts; just create a line at the
end with ~:~. Unfortunately since this is C, that's not really an
option.

**** Wrapping it up

The entire point of this endeavour is to try to make sure our code is
portable. When I write a program for one system, that program better
work on as many other systems as possible.

If any college students read this, professors don't like the "but it
worked on my machine!" excuse. (On the other hand, it takes one *mean*
professor to test with a different architecture in order to if you were
careful about memory alignment. We can't predict everything!)

~-fsanitize=undefined~ is a great flag to add when compiling; it
catches more than just memory alignment! If you add the flag and
forget about it, you will at least get a warning when undefined
behavior occurs! I'd much rather have a program that doesn't work but
I know why then a program that doesn't work and I don't know why.

** TODO Calculating a Fourier series in C, visualising one with GNUPlot :@fourier:

*** Fourier Part 1: What is a Fourier series? :C:math:gnuplot:GSL:
:PROPERTIES:
:EXPORT_FILE_NAME: fourier_series_1
:EXPORT_DATE: 2021-04-06
:END:

**** An overview of Taylor series

A fourier expansion is a way for us to approximate a function. If
you've taken calculus before, you may have heard of a similar concept,
Taylor series. With Taylor series, we can approximate any function as
a sum of polynomials. For example, we can write \( \sin x \) as

\[ sin(x) = x - \frac{x^3}{3!} + \frac{x^5}{5!} - \frac{x^7}{7!} +
\cdots \]

If we were to graph this, ([[https://www.desmos.com][try it!]]), we see that as more terms are
added, our approximation becomes more and more accurate. Here's a
small demonstration.

#+begin_src gnuplot :file static/static/gnuplot-taylor-example.png :exports results
  set title "Taylor Example"
  set xtics nomirror
  set yrange [-3:3]
  set xrange [-8:8]
  set grid
  set key left top
  set xzeroaxis lt 1 lc "black" lw 1
  set yzeroaxis lt 1 lc "black" lw 1
  set size ratio 0.7

  fac(x) = (int(x)==0) ? 1.0 : int(x) * fac(int(x)-1.0)
  taylor(x, i) = (-1)**i * (x**(2*i+1)) / fac(2*i+1)

  plot sin(x) lw 3 title "sin(x)", \
       sum [i=0:2] taylor(x, i) lw 2 title '3 terms', \
       sum [i=0:4] taylor(x, i) lw 2 title '5 terms'
#+end_src

#+RESULTS:
[[file:static/static/gnuplot-taylor-example.png]]

#+begin_src gnuplot :file static/static/gnuplot-taylor-animated-example.gif :exports results
  # delay <time> has time in units of 1/100 seconds
  # default delay between frames. Each plot generates a frame
  set terminal gif animate delay 75 loop 0
  set title "Taylor Series Animation"
  set xtics nomirror
  set yrange [-3:3]
  set xrange [-8:8]
  set grid
  set key left top
  set xzeroaxis lt 1 lc "black" lw 1
  set yzeroaxis lt 1 lc "black" lw 1
  set size ratio 0.7

  fac(x) = (int(x)==0) ? 1.0 : int(x) * fac(int(x)-1.0)
  taylor(x, n) = (-1)**n * (x**(2*n+1)) / fac(2*n+1)

  # plot sin(x) lw 3 title "sin(x)"
  do for [i=0:9] {
      plot sum [j=0:i] taylor(x, j) lw 2 title sprintf("%d term%s", i+1, i+1 > 1 ? "s" : " ")
  } 
#+end_src

#+RESULTS:
[[file:static/static/gnuplot-taylor-animated-example.gif]]

Now, Taylor series can be useful, but they have significant
limitations. First, we see that the Taylor series does a poor job
modeling periodic functions. Even though \( \sin x \) repeats, our
Taylor series does not. At large \(x\) values, this Taylor series is
completely wrong!

Second, a Taylor series relies on the function being continuous (no
holes or jumps). In addition to the function being continous, it's
derivatives must be as well. Let's consider the following graph.

#+begin_src gnuplot :file static/static/gnuplot-discontinuous-derivative.png :exports results
  set title "Discontinuous Derivative"
  set xtics nomirror
  set yrange [-3:3]
  set xrange [-8:8]
  set grid
  set key left top
  set xzeroaxis lt 1 lc "black" lw 1
  set yzeroaxis lt 1 lc "black" lw 1
  set size ratio 0.7

  set samples 1000

  f(x)  = x > 0 ? x : -1*x
  fp(x) = x < -0.01 ? -1 : x < 0.01 ? NaN : 1

  plot f(x) lw 2, fp(x) lw 2 title "fprime(x)"
#+end_src

#+RESULTS:
[[file:static/static/gnuplot-discontinuous-derivative.png]]

Even though \( f(x) \) is continuous, its derivative \( f'(x) \) is
not. As such, a Taylor series cannot be used to approximate this
function. This issue would come up even if \( f''''''''''(x) \) was
discontinuous. (Keep in mind that discontinuous is not the same thing
as 0! We can model \( f(x) = x \) as a Taylor series, as its
higher order derivatives are continuous. They just also happen to be
0. Also, \( f(x) = x \) is its own Taylor series.)

So, to summarize, Taylor series have the following issues

1. They do not model periodic functions well

2. They require the function and all of its derivatives to be
   continuous


Fortunately, the Fourier series provides answers to both of these
problems! (At least for most functions. Some functions, like a
function that is discontinuous everywhere, exist solely for the
purpose of making us sad.)

***** COMMENT Org misidentifying list

When a number appears at the start of a line followed by a period and
1. space like this, org mode will treat that as a list. This isn't a
perfect solution, but we can insert a non breaking space with ~C-q 240
ret~ after the period. Credit to Andrew Swann [[https://emacs.stackexchange.com/a/10422][here]].

**** What we're all here for, Fourier series

I'll be sticking to the basics of Fourier series for now. Let's assume
we have a periodic function \( f(x) \) that has a period of \( T \). I
am going to introduce the symbol \( l \) where \( l = \frac{T}{2} \)
While this isn't the only option, we can write the Fourier series as

\[ f(x) = \sum_{n=0}^{\infty} a_n \cos(\frac{n \pi x}{l}) + b_n
\sin(\frac{n \pi x }{l} ) \]

In this case, we can find \( a_n \) and \( b_n \) with the formulas

\[ a_n = \frac{1}{l} \int_{0}^{2l} f(x) cos(\frac{n \pi x }{l}) dx \]

\[ b_n = \frac{1}{l} \int_{0}^{2l} f(x) sin(\frac{n \pi x }{l}) dx \]

I won't go into detail as to where these formulas come from. (That is
left as an exercise for the reader. Hah!) However, I will point out
that we can adjust the limits of integration to any values we want,
just as long as the difference between the upper and lower limits
equals our period.

There is one special case that we need to discuss. When \( n = 0 \),
we need a new formula for \( a_0 \). This formula will look like

\[ a_o = \frac{1}{l} \int_{0}^{2l} f(x) dx \]

Fortunately there is no special case for \( b_0 \). This is because
when \( n = 0 \), we will get \( \sin(0) \) in our original \( a_n \)
formula. Because \( sin(0) = 0 \), we would find that \( a_n = 0 \)
all the time, which is not the case.

That is all the theory that we need to calculate the Fourier series!
As long as we can find a library that can perform integration for us,
we should be able to calculate the Fourier series for any periodic
function.

**** Using GSL to calculate an integral

***** Explanation of ~gsl_integration_qng()~

Because of inscrutible magic mumbo jumbo, I decided to use C for
calculating the Fourier expansion. In order to do that, I needed to
pick out a library that could perform the integration for me. I
settled on =GSL= or the GNU Scientific Library. There are many, many,
MANY functions available in this library, but luckily I only need to
worry about integration.

Before going too far into Fourier stuff, I'm going to do a simple
sanity check so I can make sure I'm calculating integrals correctly. I
want to calculate the following integral.

\[ \int_{0}^{8} x dx \]

To do this using =GSL=, I can use the ~gsl_integration_qng()~
function. This function has the following signature.

#+begin_src C :eval no
  int gsl_integration_qng(const gsl_function * f,
			  double a, double b,
			  double epsabs, double epsrel,
			  double * result, double * abserr,
			  size_t * neval)
#+end_src

~f~ is a pointer to a structure that contains a function pointer. For
those who don't speak nerd, this is how ~gsl_integration_qng()~ knows
what function to integrate. It's our ~f(x)~. (Mostly. The reason for
making it a structure is because the structure also contains a ~void
*~ or void pointer. This void pointer can be used to pass parameters
to the function. This could be used to let us change the slope of the
function without having to modify the function itself.

~a~ and ~b~ are the lower and upper limits of integration. That's
fairly straightforward.

~epsabs~ and ~epsrel~ help ~gsl_integration_qng()~ decide when to stop
integrating. It's not possible to integrate the function to an exact
value with =GSL=. Instead, it tries to zero in on a specific value or
best guess as to what the answer is. ~epsabs~ is the absolute error
that we want. If ~epsabs~ = 0.1, we don't know what the answer is, but
we know we are no more than 0.1 away from it. ~epsrel~ is similar, but
percentage based instead of absolute. (e.g. ~epsrel~ = 0.01 means our
answer is within 1% of the actual value.)

~result~ and ~abserr~ are used by the function to store the results
and estimated absolute error, respectively. The number of iterations
it took to calculate the result is stored in ~neval~.

It is possible for the integration to fail. This might happen if we
set the error tolerances too tight. Since the function we're
integrating is so simple, I don't think that's a likely concern.

***** ~gsl_integration_qng()~ in use

To compile this program, you will need to tell the compiler what
external libraries to use. You can do with with the ~-lgsl~ compile
flag, e.g. ~gcc main.c --lgsl~. Because =GSL= depends on another
library, =CBLAS=, you will also need the ~-lcblas~ flag. If =CBLAS=
isn't available, you can use a version of =CBLAS= provided by =GSL=
with ~-lgslcblas~. (Don't forget to install =GSL=!) Since I'm using
some math function, I'm also going to include the math library with
~-lm~.

In the end, our command will look like ~gcc main.c -lgsl -lcblas -lm~,
which will compile =main.c= and create an output file =a.out=.
(Actually I'm using =org-babel= so I don't have to deal with this, but
I'm assuming most readers here are not.)

Alright! Time to integrate! I need to preface the =gsl_integration.h=
header with =gsl/= as the headers are installed in a =gsl=
subdirectory. (If you installed this through your systems package
manager, you can probably find this file in =/usr/include/gsl/=.)

#+begin_src C :libs -lgsl -lcblas -lm :eval no-export :exports both
   #include <stdio.h>
   #include <gsl/gsl_integration.h>
   #include <math.h>

   /* This is where we define the function */
   double f(double x, void *params) {
     return x;
   }

   int main() {
     double result, error;
     double low = 0, high = 8;
     gsl_function F = {.function = &f};
     double err_abs = 0, err_rel = 1;
     size_t num_evals;

     gsl_integration_qng(&F, low, high, err_abs, err_rel,
			 &result, &error, &num_evals);
     printf("result error num_evals\n");
     printf("%f %f %ld\n", result, error, num_evals);
   }
#+end_src

#+RESULTS:
| result | error | num_evals |
|   32.0 |   0.0 |        21 |

There we go! =GSL= was able to successfully integrate \( \int_{0}^{8}
x dx \).

In the next part, we'll start using =GSL= to calculate the Fourier
series of a discontinuous, periodic function. We'll see if we can
naively get away with using the simple ~gsl_integration_qng()~
function, or if we need to find a more complicated, but more powerful, alternative.

** TODO stm8-card						  :@stm8_card:

*** COMMENT Outline

- I would like to cover the following

  - Dependencies (mermaid graphs), both what I current have and what I
    want to turn it into

  - My implementation of 256 byte framebuffer for 512 byte display

  - Issues that came up during development

    - Not remaking compilation units properly when changing function
      prototypes (commit 360dc35)

      - Compiled main with int arguments to ~i2c_send_bytes()~,
        changed in ~char~ in i2c.h, but main wasn't recompiled. Fixed
        with ~$ make clean~.

      - Also present in 170cf61

      - Would like to adjust makefile to
        automatically recompile based on dependencies / includes

    - Undefined behavior with overflow in ~space_invader.c~
      ~player_laser_tick()~. If statement right before return (present
      in commit 881c70c) overflows, relying on undefined behavior that
      overflow of signed char goes to < 0

    - Baud rate of UART, 80x less than what was expected (double check numbers)

      - HSI prescaler fixed the problem, supposedly divided clock to uart
        by factor of 8 (16 mhz -> 2 mhz), further divided by BRR1 and
        BRR2 to 9600 baud rate

	- But my baud rate was off by a factor of 80, not 8. There's a
          factor of 10 I can't account for

    - Limitations of sdcc, no passing structures directly, only pointers

      - No compound literals making initialization of nested
        structures ugly

    - Packing of structures, see comment in ~space_invader.c~ line
      18-30 in commit 881c70c

    - Padding in memory map, see commit 63ad629

      - No functional purpose I could find, takes almost 1% of my heap
        / static memory!

*** TODO stm8-card: Dependencies
:PROPERTIES:
:EXPORT_FILE_NAME: stm8-card-deps
:END:

Ideally, the dependencies would look like this.

~baseline~ is meant to represent a collection of useful macros and
maybe functions. (e.g. ~SIZEOFARRAY()~, ~CONTAINER_OF()~, etc)

~hal~ and ~stm8_board_lib~ are libraries that would be formed from
combining several pieces. The ~hal~ is a hardware abstraction library,
providing a consistent API that any code I write can use. I can "slot
in" any board lib, like the ~stm8_board_lib~, to port the code to a
different microcontroller. This will require a *lot* of restructuring
of the component pieces (~uart~. ~i2c~, etc).

#+begin_src mermaid :file static/static/mermaid-stm8-card-dep-graph.png :theme neutral :background_color transparent :exports results
graph TD;

main --- space_invader & ssd1306 & baseline & hal

space_invader & ssd1306 --- image

hal --- stm8_board_lib
stm8_board_lib --- gpio & i2c & registers & ...
#+end_src

#+RESULTS:
[[file:static/static/mermaid-stm8-card-dep-graph.png]]

Currently, they look something like this. (Double check and remake if
needed, going off of memory) [2021-03-26 Fri]

#+begin_src mermaid :file static/static/mermaid-stm8-card-dep-graph-current.png :theme neutral :background_color transparent :exports results
graph TD;

main --- space_invader & ssd1306 & baseline & i2c & uart & image

ssd1306 --- i2c & uart & baseline & image
space_invader --- image & baseline
image --- baseline
baseline --- registers
blink_code --- baseline & registers & gpio

i2c --- registers & baseline
uart --- registers

#+end_src

#+RESULTS:
[[file:static/static/mermaid-stm8-card-dep-graph-current.png]]

*** TODO stm8-card: Part 1
:PROPERTIES:
:EXPORT_FILE_NAME: stm8-card-1
:END:

* TODOs

** DONE autogenerate =ob-mermaid= graphs instead of committing pictures
CLOSED: [2021-03-27 Sat 14:50]

- Add to the publish script so that =static/static/*.png= is
  autogenerated for =ob-mermaid= graphs. I don't want redundant
  commits or to risk forgetting to export a graph.

- The problem right now is that when the ~#+RESULTS:~ are present, the
  exporter will not regenerate the files if they are missing. This
  behavior is inconsistent with, at least, org latex export, which
  does evaluate the code blocks.

  - Write a minimal example and submit a bug report [[https://github.com/kaushalmodi/ox-hugo][here]].

- Nevermind! No bug report was necessary (fortunately figured it out
  before submitting one). I was just an idiot and forgot to add
  mermaid to ~org-babel-load-languages~ in the script, meaning mermaid
  source blocks were not evaluated.

  - When I published to LaTeX, my Emacs config handles adding to
    ~org-babel-load-languages~ automatically, so I didn't notice.

** DONE Create consistent naming scheme for =ob-mermaid= graphs
CLOSED: [2021-03-27 Sat 14:50]

- Then I can add them to a =.gitignore= in =static/static=

*** TODO Possible to concatenate to ~:file~ header arg?

- e.g. ~:file $MERMAID_PREFIXname~
